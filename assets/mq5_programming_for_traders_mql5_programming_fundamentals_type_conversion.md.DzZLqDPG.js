import{_ as i,c as a,ag as e,o as h}from"./chunks/framework.CCnnzLsu.js";const r=JSON.parse('{"title":"类型转换","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://vite.dev/mq5_programming_for_traders/mql5_programming_fundamentals/type_conversion"}],["meta",{"property":"og:title","content":"类型转换"}]]},"headers":[],"relativePath":"mq5_programming_for_traders/mql5_programming_fundamentals/type_conversion.md","filePath":"mq5_programming_for_traders/mql5_programming_fundamentals/type_conversion.md","lastUpdated":1744557359000}'),p={name:"mq5_programming_for_traders/mql5_programming_fundamentals/type_conversion.md"};function n(t,s,k,l,d,c){return h(),a("div",null,s[0]||(s[0]=[e(`<h1 id="类型转换" tabindex="-1">类型转换 <a class="header-anchor" href="#类型转换" aria-label="Permalink to &quot;类型转换&quot;">​</a></h1><p>在本节中，我们将探讨类型转换的概念，目前我们先将范围限定在内置数据类型。在学习了面向对象编程（OOP）之后，我们会补充对象类型所特有的一些细微差别。</p><p>在 MQL5 中，类型转换是指改变变量或表达式数据类型的过程。MQL5 支持三种主要的类型转换方式：隐式类型转换、算术类型转换和显式类型转换。</p><h2 id="隐式类型转换" tabindex="-1">隐式类型转换 <a class="header-anchor" href="#隐式类型转换" aria-label="Permalink to &quot;隐式类型转换&quot;">​</a></h2><p>当一种类型的变量在期望另一种类型的上下文中使用时，会自动发生隐式类型转换。例如，整数值可以隐式转换为实数值。</p><p>如果在源代码的某个位置使用了一种数据类型，但程序期望的是另一种数据类型，并且这两种类型之间存在转换规则，那么类型转换就会自动发生。这种转换被称为隐式类型转换，而且它并不总是符合程序员的意图。此外，一些转换操作会产生副作用，由于编译器无法判断这些操作的使用是否是程序员有意为之，所以会用警告来标记相应的代码行。为了解决这些问题，存在显式类型转换的语法（请参阅“显式类型转换”部分）。</p><p>在学习数据类型和变量时，我们已经了解了一些隐式类型转换的规则。</p><p>具体来说，如果将非布尔类型的值赋给布尔类型的变量，那么值 0 被视为 <code>false</code>，其他所有值都被视为 <code>true</code>。在更一般的情况下，所有假定存在逻辑条件的表达式都会转换为布尔类型。例如，三元条件运算符的第一个操作数总是会被转换为布尔类型。</p><p>但是，如果将布尔类型的值赋给数值类型，那么 <code>true</code> 会变为 1，<code>false</code> 会变为 0。</p><p>当将一个实数赋值给整数类型的变量时，小数部分会被舍弃（编译器会发出警告）。另一方面，当将一个整数赋值给实数类型的变量时，可能会丢失精度（编译器也会发出警告）。我们在“整数”和“实数”部分已经讨论过这个问题。</p><p>如果同时存在整数和浮点数，所有数据都会转换为所使用的最大尺寸的浮点数（通常是 <code>double</code> 类型，除非你显式指定 <code>float</code> 类型，或者数值字面量带有后缀 <code>f</code>，例如 <code>1234.56789f</code>）。</p><p>对于不同大小的整数，也有相应的转换规则：必要时它们会进行扩展，这意味着它们会扩展为表达式中所使用的最大整数类型的大小（请参阅“算术类型转换”部分）。</p><p>除了表达式之外，在初始化和赋值过程中，当 <code>=</code> 符号左右两边的类型不匹配时，我们也经常需要进行隐式类型转换。在通过函数参数传递值以及从函数返回结果时，也会应用相同的转换规则（更多详细信息，请参阅“函数”部分）。</p><p>考虑到上述情况，一行代码中可能会进行大量的转换。如果这导致编译器发出警告，最好确认这种转换是有意为之的，并通过插入显式类型转换来消除警告。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">short</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>在这个示例中，在执行乘法运算时，变量 <code>s</code> 的类型会扩展为第二个操作数 <code>long</code> 类型，并得到一个 <code>long</code> 类型的中间结果。由于常量 <code>1.0</code> 是 <code>double</code> 类型，所以在加法运算之前，乘法的结果会被转换为 <code>double</code> 类型。最终的结果也是 <code>double</code> 类型；然而，变量 <code>p</code> 是 <code>int</code> 类型，因此会进行从 <code>double</code> 类型到 <code>int</code> 类型的隐式转换。</p><p>特殊类型 <code>datetime</code> 和 <code>color</code> 分别按照 8 字节和 4 字节整数的规则进行处理。但对于日期和时间，其最大值有更严格的限制——32535244799，这对应于 <code>D&#39;3000.12.31 23:59:59&#39;</code>。</p><p>大多数类型都可以与字符串进行隐式的相互转换，但结果并不总是合适的，所以编译器会发出“从‘数字’到‘字符串’的隐式转换”和“从‘字符串’到‘数字’的隐式转换”的警告，以便程序员进行检查。例如，将字符串转换为整数时，字符串只能包含数字，并且开头可以有 <code>+</code>/<code>-</code> 字符。将字符串转换为实数时，除了数字之外，还可以包含小数点 <code>.</code> 以及带有“指数”的表示形式（<code>e</code> 或 <code>E</code>，例如 <code>+1.2345e-1</code>）。如果在字符串中遇到不支持的字符（例如字母），那么字符串的剩余部分将被完全舍弃。</p><p>例如，字符串形式的日期和时间（<code>&quot;2021.12.12 00:00&quot;</code>）不能无损失地赋值给 <code>datetime</code> 类型的变量，因为 <code>datetime</code> 是一个整数（表示秒数）。在这种情况下，从字符串中读取数字时，会在遇到第一个点时结束，也就是说，这个数字将得到值 2021。这个秒数对应于 1970 年的第 34 分钟。</p><p>对于此类转换，有专门的函数（请参阅“数据转换”部分）。</p><p>唯一被禁止的隐式和显式类型转换方向是从字符串转换为布尔类型。在这种情况下，编译器会显示错误消息“无法将类型‘字符串’隐式转换为‘布尔’类型”。</p><p>本章的示例在 <code>TypeConversion.mq5</code> 中提供。</p><h2 id="算术类型转换" tabindex="-1">算术类型转换 <a class="header-anchor" href="#算术类型转换" aria-label="Permalink to &quot;算术类型转换&quot;">​</a></h2><p>在对不同类型的操作数进行算术运算时会出现算术类型转换。编译器会尝试保持最大精度，但会对潜在的数据丢失发出警告。例如，在整数除法中，结果会转换为实数类型。</p><p>在算术计算和比较表达式中，不同类型的值经常被用作操作数。为了正确处理它们，有必要将这些类型统一到某种“共同的基准”。编译器会在没有程序员干预的情况下尝试完成这一操作，除非程序员指定了显式的转换规则（请参阅“显式类型转换”部分）。在这种情况下，只要有可能，编译器在处理数字时会尽量保留最大精度。特别是，它会增加整数的存储容量，并在涉及到整数和实数时将类型从整数转换为实数。</p><p>整数扩展意味着将 <code>bool</code>、<code>char</code>、<code>unsigned char</code>、<code>short</code>、<code>unsigned short</code> 转换为 <code>int</code>（如果 <code>int</code> 不足以存储特定数字，则转换为 <code>unsigned int</code>）。较大的值可以转换为 <code>long</code> 和 <code>unsigned long</code>。</p><p>如果变量的类型无法存储表达式求值时得到的类型的结果，编译器会发出警告：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 常量值的截断</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 由于类型转换可能导致数据丢失</span></span></code></pre></div><p>初始化变量 <code>x</code> 和 <code>y</code> 的表达式中包含实数 <code>1.0</code>，所以其他操作数（在这种情况下是常量 <code>10</code>）会被转换为 <code>double</code> 类型，除法的结果也将是 <code>double</code> 类型。然而，变量的类型是 <code>int</code>，因此会发生向 <code>int</code> 类型的隐式转换。</p><p>计算 <code>1.0 / 10</code> 是由编译器在编译期间完成的，因此它得到一个 <code>double</code> 类型的常量（<code>0.1</code>）。当然，在实际中，初始化常量不太可能超过接收变量的大小。所以编译器的警告“常量值的截断”可以被认为比较少见。它只是以最简化的方式展示了这个问题。</p><p>然而，由于基于变量的计算，也可能会发生类似的数据丢失。我们在这里看到的编译器的第二个警告（“由于类型转换可能导致数据丢失”）出现的频率要高得多。此外，数据丢失不仅可能在从实数类型转换为整数类型时发生，反之亦然。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LONG_MAX;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 常量值的截断</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m1;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 由于类型转换可能导致数据丢失</span></span></code></pre></div><p>如我们所知，<code>double</code> 类型不能精确表示大整数（尽管它的有效值范围比 <code>long</code> 大得多）。</p><p>由于类型不匹配，我们可能会遇到的另一个警告是：“整数常量溢出”。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m1;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // 正确: m2 = 1000000000000000000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 整数常量溢出</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                   // m3 = -1486618624</span></span></code></pre></div><p>在 MQL5 中，整数常量的类型是 <code>int</code>，所以在计算百万乘以百万时，会考虑 <code>int</code> 类型的范围，其范围等于 <code>INT_MAX</code>（<code>2147483647</code>）。值 <code>1000000000000000000</code> 会导致溢出，<code>m3</code> 得到的是这个值除以 <code>int</code> 类型范围后的余数（关于这一点的更多内容见下面的侧边栏）。</p><p>接收变量 <code>m3</code> 的类型是 <code>long</code> 并不意味着表达式中的值必须事先转换为 <code>long</code> 类型。这只会在赋值的那一刻发生。为了使乘法按照 <code>long</code> 类型的规则进行，需要以某种方式在表达式中直接指定 <code>long</code> 类型。这可以通过显式转换或使用变量来实现。特别是，使用 <code>long</code> 类型的变量 <code>m1</code> 来计算相同的乘积（如 <code>m1 * m1</code>），会在 <code>m2</code> 中得到正确的结果。</p><h4 id="有符号和无符号整数" tabindex="-1">有符号和无符号整数 <a class="header-anchor" href="#有符号和无符号整数" aria-label="Permalink to &quot;有符号和无符号整数&quot;">​</a></h4><p>程序并不总是完美编写的，能防范所有可能的错误。因此，有时在计算过程中得到的整数无法存储在所选的整数类型变量中。然后它会得到这个值除以相应字节数（类型大小）所能表示的最大值（<code>M</code>）加 1 的余数。所以对于大小为 1 到 4 字节的整数类型，<code>M + 1</code> 分别是 <code>256</code>、<code>65536</code>、<code>4294967296</code> 和 <code>18446744073709551616</code>。</p><p>但对于有符号类型有一个细微差别。如我们所知，对于有符号数，值的总范围大约平均分配在正数和负数区域。因此，新的“余数”值在 50% 的情况下可能会超过正数或负数的限制。在这种情况下，数字会变成“相反”的数：它改变符号，并且与原始值的距离为 <code>M</code>。</p><p>重要的是要理解，这种转换仅仅是由于对内部表示中的位状态的不同解释，并且对于有符号和无符号数，位状态本身是相同的。</p><p>让我们用最小的整数类型 <code>char</code> 和 <code>uchar</code> 的例子来解释这一点。</p><p>由于 <code>unsigned char</code> 可以存储从 <code>0</code> 到 <code>255</code> 的值，<code>256</code> 会映射到 <code>0</code>，<code>-1</code> 会映射到 <code>255</code>，<code>300</code> 会映射到 <code>44</code>，以此类推。如果我们尝试将 <code>300</code> 写入普通的有符号 <code>char</code> 中，我们也会得到 <code>44</code>，因为 <code>44</code> 在 <code>0</code> 到 <code>127</code> 的范围内（<code>char</code> 的正数范围）。然而，如果将 <code>char</code> 和 <code>uchar</code> 变量都设置为 <code>3000</code>，情况就会不同。<code>3000</code> 除以 <code>256</code> 的余数是 <code>184</code>。它在 <code>uchar</code> 中保持不变。然而，对于 <code>char</code>，相同的位组合会得到 <code>-72</code>。很容易验证 <code>184</code> 和 <code>-72</code> 相差 <code>256</code>。</p><p>在下面的例子中，由于编译器的警告，很容易发现问题。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 常量值的截断</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // -72</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uchar uc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 常量值的截断</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uc);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 184</span></span></code></pre></div><p>然而，如果在计算过程中得到一个特别大的数，将不会有警告。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c55 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c55 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c55;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 正确! </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sm);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 3025 -&gt; -47</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uchar um </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c55 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c55;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 正确!</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(um);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 3025 -&gt; 209</span></span></code></pre></div><p>当在同一个表达式中使用相同大小的有符号和无符号整数时，也会出现类似的效果，因为有符号操作数会被转换为无符号数。例如：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">49</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // -98</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 4294967258 = 4294967296 - 38</span></span></code></pre></div><p>当两个负整数相加时，我们得到预期的结果。第二个表达式将 <code>-38</code> 的和映射到“相反”的无符号数 <code>4294967258</code>。</p><p>由于这些潜在的问题，不建议在同一个表达式中混合使用有符号和无符号类型。</p><p>此外，如果我们从无符号整数中减去某个数，我们需要确保结果不会为负数。否则，它将被转换为正数，并且可能会扭曲算法的逻辑，特别是 <code>while</code> 循环中检查变量是否“大于或等于零”的条件：由于无符号数总是非负的，我们很容易得到一个无限循环，即程序挂起。</p><h2 id="显式类型转换" tabindex="-1">显式类型转换 <a class="header-anchor" href="#显式类型转换" aria-label="Permalink to &quot;显式类型转换&quot;">​</a></h2><p>显式类型转换让程序员能够控制类型转换过程。它有两种形式：C 风格（<code>(target)</code>）和“函数”风格（<code>target()</code>）。当你需要明确指示编译器在不同类型之间进行转换时，就会使用显式类型转换，例如在对实数进行舍入操作时，或者需要进行连续的类型转换时。</p><p>理解隐式、算术和显式类型转换之间的区别，对于确保操作的正确执行以及避免数据丢失至关重要。这些知识有助于程序员在 MQL5 开发中有效地利用这一机制。</p><p>对于显式类型转换，MQL5 支持两种表示形式：C 风格和“函数式”。C 风格的语法如下：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>目标类型 t = (目标类型)s;</span></span></code></pre></div><p>其中，“目标类型”是目标数据类型的名称。任何表达式都可以作为数据源 <code>s</code>。如果表达式中包含运算，必须将其用括号括起来，这样类型转换才会应用于整个表达式。</p><p>另一种“函数式”语法如下：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>目标类型 t = 目标类型(s);</span></span></code></pre></div><p>下面来看几个例子。</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 14</span></span></code></pre></div><p>这里，两个实数相除的结果被显式转换为 <code>int</code> 类型。这样，程序员就表明了舍弃小数部分的意图，编译器也不会发出警告。需要注意的是，MQL5 有一组用于以各种方式对实数进行四舍五入的函数（请参阅数学函数）。</p><p>相反，如果想对整数进行运算并得到实数结果，则需要对操作数（在表达式中）进行类型转换：</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 14.28571428571429</span></span></code></pre></div><p>对其中一个操作数进行转换就足以使其他操作数自动转换为相同的类型。</p><p>如有必要，可以依次执行多个类型转换操作。由于类型转换操作是右结合的，目标类型将从右到左依次应用。在下面的示例中，我们先将商转换为 <code>float</code> 类型（这种转换可以更紧凑地表示值，减少字符数），然后再转换为 <code>string</code> 类型。如果不进行显式的字符串转换，编译器会发出“隐式数字到字符串转换”的警告。</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Result:&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (string)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Result:14.28571</span></span></code></pre></div><p>不要仅仅为了避免编译器警告而使用显式类型转换。如果这样做没有实际依据，你可能会掩盖程序中的潜在错误。</p>`,69)]))}const g=i(p,[["render",n]]);export{r as __pageData,g as default};
