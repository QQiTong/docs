import{_ as t}from"./chunks/mql5storage_update_icon.BBTmqgY4.js";import{_ as a,c as r,ag as o,o as i}from"./chunks/framework.CCnnzLsu.js";const l="/metaeditor/merge_example_1.png",m="/metaeditor/merge_example_2.png",u=JSON.parse('{"title":"合并修改","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://vite.dev/metaeditor/mql5storage/mql5storage_merging"}],["meta",{"property":"og:title","content":"合并修改"}]]},"headers":[],"relativePath":"metaeditor/mql5storage/mql5storage_merging.md","filePath":"metaeditor/mql5storage/mql5storage_merging.md","lastUpdated":1744293048000}'),s={name:"metaeditor/mql5storage/mql5storage_merging.md"};function n(p,e,_,d,g,c){return i(),r("div",null,e[0]||(e[0]=[o('<h1 id="合并修改" tabindex="-1">合并修改 <a class="header-anchor" href="#合并修改" aria-label="Permalink to &quot;合并修改&quot;">​</a></h1><p>当团队协同工作于一个 <a href="/metaeditor/mql5storage/projects#shared">共享项目</a> 时，也许会发生同一文件被多个用户同时编辑的情况。 为了避免这些修改被彼此覆盖，MetaEditor 具有合并数据的功能。</p><p>如果您尝试将某个已被某人修改的文件保存到存储中，MetaEditor 会提示您首先获取最新的更改。 当收到更改时，会尝试合并数据: 将存储的更改应用到本地数据副本，并尝试保存当前的本地更改。</p><ul><li>合并仅适用于采用 ANSI 格式的源代码（mq4，mq5，mqh，cpp 和 h）的文本文件。 Bmp 和 wav 文件总是被较新的版本完全替换。</li><li>源代码文件逐行比较。出现冲突时（例如，本地文件和存储库中相应文件中的相同行被更改），合并算法目标是最大限度地保留本地更改。</li></ul><h2 id="合并示例" tabindex="-1">合并示例 <a class="header-anchor" href="#合并示例" aria-label="Permalink to &quot;合并示例&quot;">​</a></h2><p>我们来参照一个合并两个文件的典型案例。 如上所述，在合并期间，逐行比较源代码文件。 如果存储中的文件包含本地文件中不存在的行，那么这些行会被添加。参照以下合并两个文件的示例:</p><p><img src="'+l+'" alt="合并两个文件的示例"></p><p>在您点击后<img src="'+t+'" alt="从存储更新">从存储更新，本地文件保持不变，因为本地更改具有更高的优先级。 如果存储文件包含新行 &quot;x=0;&quot;，它会被添加，而 &quot;return(true);&quot; 这行将保持不变:</p><p><img src="'+m+'" alt="合并两个文件的示例"></p><ul><li>合并的主要原则是本地数据拥有更高优先级。 该算法旨在最大限度地保护本地更改。</li><li>在合并过程中有许多类型的冲突。在本节中，只考虑了一种最常见的情况。 合并算法很复杂，并且在分析文件中提供了一​​个全面的方法。关于合并的更多信息，可以参阅<a href="https://svnbook.red-bean.com/en/1.2/svn-book.html" title="关于集成的书籍" target="_blank" rel="noreferrer">有关集成的书籍</a> 中的测试程序。</li></ul><hr>',11)]))}const f=a(s,[["render",n]]);export{u as __pageData,f as default};
