import{_ as e,c as t,ag as a,o as r}from"./chunks/framework.CCnnzLsu.js";const o="/images/article/unify_price/1.png",l="/images/article/unify_price/2.png",c="/images/article/unify_price/3.png",m=JSON.parse('{"title":"回测中可能忽略的问题","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://vite.dev/article/unify_price"}],["meta",{"property":"og:title","content":"回测中可能忽略的问题"}]]},"headers":[],"relativePath":"article/unify_price.md","filePath":"article/unify_price.md","lastUpdated":1745411614000}'),n={name:"article/unify_price.md"};function s(p,i,d,_,u,g){return r(),t("div",null,i[0]||(i[0]=[a('<h1 id="回测中可能忽略的问题" tabindex="-1">回测中可能忽略的问题 <a class="header-anchor" href="#回测中可能忽略的问题" aria-label="Permalink to &quot;回测中可能忽略的问题&quot;">​</a></h1><p>如果你想在量化交易中取得成功，理解今天的内容绝对至关重要。否则，你的回测、你的复盘都是毫无意义。曾今开发过一个策略,在过去12年间，在四十多个交易品种上都呈现出非常可观的盈利能力，</p><p>在众多交易品种中，使用同样的参数，却能在绝大部分品种上盈利，零星几个亏损，且亏损幅度不大，最多的是BTC。看它的收益率、盈利因子都不低，交易笔数也不少。我们随便测两个：</p><ul><li><strong>USTEC</strong>：资金曲线有亏有赚，并非一路上涨。</li><li><strong>黄金</strong>：同样起起伏伏，但12年历史行情后，资金曲线基本走成“直线”。</li><li><strong>澳元加元</strong>：表现正常一些，资金曲线不是笔直的直线。</li></ul><p>从盘面上看具体做单细节（回测2012-2024年）：订单有亏有赚，属于正常的止损止盈模式，一单一结，没有浮盈加仓。止损和止盈点位较大，属于波段交易，非高频剥头皮策略。回测结果也很常规：胜率67%，平均盈利39U，平均亏损58U（开发阶段使用较小单位分析，故数值较小，但比例正常）。</p><p><img src="'+o+'" alt=""></p><p>后面发现问题：<strong>未认识到统一价位模式的重要性</strong>。将判断信号的K线往前移了一根，回测结果就大变样：修改前资金曲线平稳盈利，修改后盈利效果大打折扣。</p><p><img src="'+l+'" alt=""></p><h3 id="举例说明核心问题" tabindex="-1">举例说明核心问题 <a class="header-anchor" href="#举例说明核心问题" aria-label="Permalink to &quot;举例说明核心问题&quot;">​</a></h3><p>假设交易逻辑以RSI超买超卖开仓，若以当前未走完的K线（<code>i=0</code>，实时浮动指标值）作为判断依据，就会出现信号错误。因为实时K线的指标值是动态变化的，未固定，而回测环境使用的是历史固定K线（<code>i=1</code>及之后，开高低收已确定）。若代码中未统一处理，实盘与回测的交易记录和绩效会相差甚远。</p><h3 id="为什么要统一回测与实盘的价位模式" tabindex="-1">为什么要统一回测与实盘的价位模式？ <a class="header-anchor" href="#为什么要统一回测与实盘的价位模式" aria-label="Permalink to &quot;为什么要统一回测与实盘的价位模式？&quot;">​</a></h3><p>以MT5为例，实盘与回测的报价处理机制不同：<br><img src="'+c+'" alt=""></p><ol><li><strong>实盘环境</strong>： <ul><li>平台服务器（MT5 Server）接收实时报价，传递到本地MT5客户端（MT5 Client），再传递给EA，最后到<code>on tick</code>方法。</li><li>若前一个报价（Tick1）在<code>on tick</code>中未执行完毕，后续报价（Tick2、Tick3）会被丢弃，EA无法处理——代码运行效率影响报价接收。</li></ul></li><li><strong>回测环境</strong>： <ul><li>本地测试环境直接生成历史报价，传递给EA和<code>on tick</code>方法。</li><li>会等待前一个报价执行完毕，再处理后续报价，不会丢弃任何Tick——保证所有历史价格被处理。</li></ul></li></ol><p><strong>结论</strong>：实盘可能错过实时报价，回测则“不离不弃”，两者天然存在偏差。若再使用实时K线（<code>i=0</code>）作为判断依据，不统一价位模式，实盘与回测绩效会严重脱节。</p><h3 id="建议" tabindex="-1">建议 <a class="header-anchor" href="#建议" aria-label="Permalink to &quot;建议&quot;">​</a></h3><ol><li>开发EA时，尽量使用历史固定K线（如<code>i=1</code>）作为判断依据，避免依赖实时浮动数据。</li><li>务必统一回测与实盘的价位模式，否则回测无参考意义。</li><li>不要迷信“买EA躺赚”，花时间学习自己开发才是王道；若购买，尽量买断源码，清楚策略逻辑。</li></ol>',16)]))}const f=e(n,[["render",s]]);export{m as __pageData,f as default};
