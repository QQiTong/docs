import{_ as i,c as a,ag as n,o as t}from"./chunks/framework.CCnnzLsu.js";const h="/images/mq5_programming_for_traders/strings_comparison.png",p="/images/mq5_programming_for_traders/stringformat.png",c=JSON.parse('{"title":"字符串和符号处理","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://vite.dev/mq5_programming_for_traders/common_mql5_apis/working_with_strings_and_symbols"}],["meta",{"property":"og:title","content":"字符串和符号处理"}]]},"headers":[],"relativePath":"mq5_programming_for_traders/common_mql5_apis/working_with_strings_and_symbols.md","filePath":"mq5_programming_for_traders/common_mql5_apis/working_with_strings_and_symbols.md","lastUpdated":1745411614000}'),e={name:"mq5_programming_for_traders/common_mql5_apis/working_with_strings_and_symbols.md"};function l(k,s,r,d,o,g){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="字符串和符号处理" tabindex="-1">字符串和符号处理 <a class="header-anchor" href="#字符串和符号处理" aria-label="Permalink to &quot;字符串和符号处理&quot;">​</a></h1><p>尽管计算机的名称源于动词“计算”，但它们不仅在处理数字方面表现出色，在处理任何非结构化信息时也同样出色，其中最典型的例子就是文本。在 MQL 程序中，文本的使用无处不在，从程序本身的名称到交易订单中的注释都离不开它。为了在 MQL5 中处理文本，提供了内置的字符串类型，它允许你对任意长度的字符序列进行操作。</p><p>为了对字符串执行常见操作，MQL5 API 提供了丰富的函数。根据功能用途，这些函数可以大致分为以下几类：字符串初始化、字符串拼接、在字符串内搜索和替换片段、将字符串转换为字符数组、访问单个字符以及字符串格式化。</p><p>本章中的大多数函数会返回执行状态的指示：成功或错误。对于返回类型为 <code>bool</code> 的函数，<code>true</code> 通常表示成功，<code>false</code> 表示错误。对于返回类型为 <code>int</code> 的函数，值为 0 或 -1 可被视为错误，具体情况会在每个函数的描述中说明。在所有这些情况下，开发者可以了解问题的本质。为此，可以调用 <code>GetLastError</code> 函数获取具体的错误代码，文档中提供了所有代码及其解释的列表。需要注意的是，在收到错误标志后应立即调用 <code>GetLastError</code>，因为算法中后续执行的每条指令都可能导致另一个错误。</p><h2 id="字符串的初始化与度量" tabindex="-1">字符串的初始化与度量 <a class="header-anchor" href="#字符串的初始化与度量" aria-label="Permalink to &quot;字符串的初始化与度量&quot;">​</a></h2><p>从字符串类型的相关章节我们了解到，在代码中描述一个 <code>string</code> 类型的变量，它即可投入使用。</p><p>对于任何 <code>string</code> 类型的变量，会为其服务结构体分配 12 字节的空间，该结构体是字符串的内部表示形式。结构体中包含存储文本的内存地址（指针）以及一些其他元信息。文本本身也需要足够的内存，但这块缓冲区的分配存在一些不太明显的优化机制。</p><p>具体来说，我们可以在声明字符串的同时进行显式初始化，包括初始化为空字面值：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 指向包含 &#39;\\0&#39; 的字面值的指针</span></span></code></pre></div><p>在这种情况下，指针将直接指向该字面值，并且不会为缓冲区分配内存（即使字面值很长）。显然，已经为该字面值分配了静态内存，并且可以直接使用。只有当程序中的任何指令改变字符串的内容时，才会为缓冲区分配内存。例如（注意，字符串允许使用加法操作符 <code>+</code>）：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (string)n;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 指向包含 &quot;1&quot;&#39;\\0&#39;[加上预留空间] 的内存的指针</span></span></code></pre></div><p>从这时起，字符串实际上包含文本“1”，严格来说，需要为两个字符分配内存：数字“1”和隐含的字符串结束符 <code>&#39;\\0&#39;</code>。然而，系统会分配一个更大的缓冲区，并预留一些空间。</p><p>当我们声明一个没有初始值的变量时，编译器仍然会对其进行隐式初始化，不过在这种情况下，它会被初始化为一个特殊的 <code>NULL</code> 值：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string z;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 未为指针分配内存，指针 = NULL</span></span></code></pre></div><p>这样的字符串每个结构体仅需 12 字节，并且指针不指向任何地方，这就是 <code>NULL</code> 的含义。</p><p>在 MQL5 编译器的未来版本中，这种行为可能会改变，对于空字符串，可能会始终初始分配一小片内存，并提供一些预留空间。</p><p>除了这些内部特性外，<code>string</code> 类型的变量与其他类型的变量没有区别。然而，由于字符串的长度可能是可变的，更重要的是，在算法执行过程中它们的长度可能会发生变化，这可能会对内存分配的效率和性能产生不利影响。</p><p>例如，如果程序在某个时刻需要向字符串中添加一个新单词，可能会发现为该字符串分配的内存不足。然后，MQL 程序的执行环境（用户无法察觉）会找到一个更大的新空闲内存块，并将旧值连同新添加的单词一起复制到那里。之后，字符串的服务结构体中的旧地址将被新地址替换。</p><p>如果存在许多这样的操作，由于复制操作导致的速度减慢可能会变得明显，此外，程序内存还会出现碎片化问题：复制后释放的旧的小内存区域会形成空隙，这些空隙的大小不适合存储大字符串，从而导致内存浪费。当然，终端能够控制这种情况并重新组织内存，但这也需要付出一定的代价。</p><p>解决这个问题最有效的方法是提前显式指定字符串缓冲区的大小，并使用内置的 MQL5 API 函数对其进行初始化，我们将在本节后面部分介绍这些函数。</p><p>这种优化的基础在于，分配的内存大小可能会超过字符串当前（以及潜在的未来）的长度，字符串的长度由文本中的第一个空字符决定。因此，我们可以为 100 个字符分配一个缓冲区，但从一开始就在最前面放置 <code>&#39;\\0&#39;</code>，这将得到一个长度为零的字符串（&quot;&quot;）。</p><p>当然，在这种情况下，假设程序员能够大致提前计算出字符串的预期长度或其增长速度。</p><p>由于 MQL5 中的字符串基于双字节字符（这确保了对 Unicode 的支持），字符串和缓冲区的字符大小应乘以 2 才能得到占用和分配的内存字节数。</p><p>本节末尾将给出使用所有函数的综合示例（<code>StringInit.mq5</code>）。</p><h3 id="bool-stringinit-string-variable-int-capacity-0-ushort-character-0" tabindex="-1">bool StringInit(string &amp;variable, int capacity = 0, ushort character = 0) <a class="header-anchor" href="#bool-stringinit-string-variable-int-capacity-0-ushort-character-0" aria-label="Permalink to &quot;bool StringInit(string &amp;variable, int capacity = 0, ushort character = 0)&quot;">​</a></h3><p><code>StringInit</code> 函数用于初始化（分配和填充内存）以及反初始化（释放内存）字符串。要处理的变量通过第一个参数传递。</p><p>如果 <code>capacity</code> 参数大于 0，则为字符串分配一个指定大小的缓冲区（内存区域），并用 <code>character</code> 字符填充。如果 <code>character</code> 为 0，那么字符串的长度将为零，因为第一个字符是结束符。</p><p>如果 <code>capacity</code> 参数为 0，则释放先前分配的内存。变量的状态将与刚声明但未初始化时相同（指向缓冲区的指针为 <code>NULL</code>）。更简单地说，将字符串变量设置为 <code>NULL</code> 也能达到同样的效果。</p><p>该函数返回成功指示（<code>true</code>）或错误指示（<code>false</code>）。</p><h3 id="bool-stringreserve-string-variable-uint-capacity" tabindex="-1">bool StringReserve(string &amp;variable, uint capacity) <a class="header-anchor" href="#bool-stringreserve-string-variable-uint-capacity" aria-label="Permalink to &quot;bool StringReserve(string &amp;variable, uint capacity)&quot;">​</a></h3><p><code>StringReserve</code> 函数增加或减少字符串变量的缓冲区大小，至少达到 <code>capacity</code> 参数中指定的字符数。如果 <code>capacity</code> 值小于当前字符串的长度，该函数不执行任何操作。实际上，缓冲区的大小可能会比请求的大：执行环境出于对字符串未来操作效率的考虑会这样做。因此，如果使用减小缓冲区大小的值调用该函数，它可能会忽略该请求并仍然返回 <code>true</code>（“无错误”）。</p><p>当前缓冲区的大小可以使用 <code>StringBufferLen</code> 函数获取（见下文）。</p><p>如果成功，该函数返回 <code>true</code>，否则返回 <code>false</code>。</p><p>与 <code>StringInit</code> 不同，<code>StringReserve</code> 函数不会更改字符串的内容，也不会用字符填充它。</p><h3 id="bool-stringfill-string-variable-ushort-character" tabindex="-1">bool StringFill(string &amp;variable, ushort character) <a class="header-anchor" href="#bool-stringfill-string-variable-ushort-character" aria-label="Permalink to &quot;bool StringFill(string &amp;variable, ushort character)&quot;">​</a></h3><p><code>StringFill</code> 函数用 <code>character</code> 字符填充指定的字符串变量，填充范围为其当前的整个长度（直到第一个空字符）。如果为字符串分配了缓冲区，则在原位进行修改，无需中间的换行和复制操作。</p><p>该函数返回成功指示（<code>true</code>）或错误指示（<code>false</code>）。</p><h3 id="int-stringbufferlen-const-string-variable" tabindex="-1">int StringBufferLen(const string &amp;variable) <a class="header-anchor" href="#int-stringbufferlen-const-string-variable" aria-label="Permalink to &quot;int StringBufferLen(const string &amp;variable)&quot;">​</a></h3><p>该函数返回为字符串变量 <code>variable</code> 分配的缓冲区大小。</p><p>请注意，对于用字面值初始化的字符串，最初不会分配缓冲区，因为指针指向该字面值。因此，即使 <code>StringLen</code> 函数（见下文）返回的字符串长度可能更大，该函数仍将返回 0。</p><p>值 -1 表示该字符串属于客户端终端且不能被更改。</p><h3 id="bool-stringsetlength-string-variable-uint-length" tabindex="-1">bool StringSetLength(string &amp;variable, uint length) <a class="header-anchor" href="#bool-stringsetlength-string-variable-uint-length" aria-label="Permalink to &quot;bool StringSetLength(string &amp;variable, uint length)&quot;">​</a></h3><p>该函数为字符串变量 <code>variable</code> 设置指定的字符长度 <code>length</code>。<code>length</code> 的值不能大于字符串的当前长度。换句话说，该函数只允许缩短字符串，而不允许延长它。当调用 <code>StringAdd</code> 函数或执行加法操作 <code>+</code> 时，字符串的长度会自动增加。</p><p><code>StringSetLength</code> 函数的等效操作是调用 <code>StringSetCharacter(variable, length, 0)</code>（见“处理符号和代码页”部分）。</p><p>如果在调用该函数之前已经为字符串分配了缓冲区，该函数不会更改它。如果字符串没有缓冲区（它指向一个字面值），减小长度会导致分配一个新的缓冲区，并将缩短后的字符串复制到其中。</p><p>该函数在成功时返回 <code>true</code>，在失败时返回 <code>false</code>。</p><h3 id="int-stringlen-const-string-text" tabindex="-1">int StringLen(const string text) <a class="header-anchor" href="#int-stringlen-const-string-text" aria-label="Permalink to &quot;int StringLen(const string text)&quot;">​</a></h3><p>该函数返回字符串 <code>text</code> 中的字符数。字符串结束符 <code>\\0</code> 不计算在内。</p><p>请注意，参数是按值传递的，因此不仅可以计算变量中字符串的长度，还可以计算任何其他中间值（计算结果或字面值）的字符串长度。</p><p>为了演示上述函数，创建了 <code>StringInit.mq5</code> 脚本。它使用了 <code>PRT</code> 宏的一个特殊版本 <code>PRTE</code>，该宏将表达式的结果解析为 <code>true</code> 或 <code>false</code>，如果是 <code>false</code>，还会额外输出错误代码：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(#A, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;=&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (A) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;true&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;false:&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (string)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetLastError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>为了将字符串及其当前度量信息（字符串长度和缓冲区大小）输出到日志进行调试，实现了 <code>StrOut</code> 函数：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&#39;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, s, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&#39; [&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringLen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;] &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringBufferLen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>它使用了内置的 <code>StringLen</code> 和 <code>StringBufferLen</code> 函数。</p><p>测试脚本在 <code>OnStart</code> 函数中对一个字符串执行了一系列操作：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringReserve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 成功，但我们得到的缓冲区比请求的大：260</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringReserve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 成功，缓冲区增加到 500</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringSetLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 成功：字符串被缩短</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;age&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringReserve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 成功：缓冲区保持为 500</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringSetLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 失败：不支持通过 StringSetLength 延长字符串</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   //     via StringSetLength</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringInit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;$&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 成功：通过填充增加字符串长度</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   //     缓冲区保持不变</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringFill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 成功：字符串因填充 0 而变为空字符串，缓冲区不变</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringInit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 成功：字符串清零，包括缓冲区</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                // 我们也可以直接写 s = NULL;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>该脚本将在日志中记录以下消息：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>&#39;message&#39; [7] 0</span></span>
<span class="line"><span>StringReserve(s,100)=true</span></span>
<span class="line"><span>&#39;message&#39; [7] 260</span></span>
<span class="line"><span>StringReserve(s,500)=true</span></span>
<span class="line"><span>&#39;message&#39; [7] 500</span></span>
<span class="line"><span>StringSetLength(s,4)=true</span></span>
<span class="line"><span>&#39;mess&#39; [4] 500</span></span>
<span class="line"><span>StringReserve(s,10)=true</span></span>
<span class="line"><span>&#39;message&#39; [7] 500</span></span>
<span class="line"><span>StringSetLength(s,8)=false:5035</span></span>
<span class="line"><span>&#39;message&#39; [7] 500</span></span>
<span class="line"><span>StringInit(s,8,&#39;$&#39;)=true</span></span>
<span class="line"><span>&#39;$$$$$$$$&#39; [8] 500</span></span>
<span class="line"><span>StringFill(s,0)=true</span></span>
<span class="line"><span>&#39;&#39; [0] 500</span></span>
<span class="line"><span>StringInit(s,0)=true</span></span>
<span class="line"><span>&#39;&#39; [0] 0</span></span></code></pre></div><p>请注意，调用 <code>StringSetLength</code> 并尝试增加字符串长度时，以错误 5035（<code>ERR_STRING_SMALL_LEN</code>）结束。</p><h2 id="字符串拼接" tabindex="-1">字符串拼接 <a class="header-anchor" href="#字符串拼接" aria-label="Permalink to &quot;字符串拼接&quot;">​</a></h2><p>字符串拼接可能是最常见的字符串操作了。在 MQL5 中，可以使用 <code>+</code> 或 <code>+=</code> 运算符来完成拼接。<code>+</code> 运算符会连接两个字符串（<code>+</code> 运算符左右两边的操作数），并创建一个临时的拼接字符串，这个临时字符串可以赋值给目标变量，或者传递给表达式的其他部分（比如函数调用）。<code>+=</code> 运算符则是将 <code>+=</code> 运算符右边的字符串追加到左边的字符串（变量）上。</p><p>除此之外，MQL5 API 还提供了几个用于从其他字符串或其他类型的元素组合成字符串的函数。</p><p>函数的使用示例在 <code>StringAdd.mq5</code> 脚本中给出，在对这些函数进行描述之后会对该脚本进行讲解。</p><h3 id="bool-stringadd-string-variable-const-string-addition" tabindex="-1">bool StringAdd(string &amp;variable, const string addition) <a class="header-anchor" href="#bool-stringadd-string-variable-const-string-addition" aria-label="Permalink to &quot;bool StringAdd(string &amp;variable, const string addition)&quot;">​</a></h3><p>该函数将指定的 <code>addition</code> 字符串追加到字符串变量 <code>variable</code> 的末尾。只要有可能，系统会使用字符串变量已有的缓冲区（如果其大小足以容纳拼接后的结果），而无需重新分配内存或复制字符串。</p><p>该函数等同于 <code>variable += addition</code> 运算符，时间开销和内存消耗大致相同。</p><p>函数成功时返回 <code>true</code>，出错时返回 <code>false</code>。</p><h3 id="int-stringconcatenate-string-variable-void-argument1-void-argument2-void-argumenti" tabindex="-1">int StringConcatenate(string &amp;variable, void argument1, void argument2 [, void argumentI...]) <a class="header-anchor" href="#int-stringconcatenate-string-variable-void-argument1-void-argument2-void-argumenti" aria-label="Permalink to &quot;int StringConcatenate(string &amp;variable, void argument1, void argument2 [, void argumentI...])&quot;">​</a></h3><p>该函数将两个或更多内置类型的参数转换为字符串表示形式，并将它们连接到 <code>variable</code> 字符串中。参数从函数的第二个参数开始传递。不支持将数组、结构体、对象、指针作为参数。</p><p>参数的数量必须在 2 到 63 之间。</p><p>字符串参数会按原样添加到结果变量中。</p><p><code>double</code> 类型的参数会以最高精度进行转换（最多 16 位有效数字），如果科学计数法更紧凑，会选择使用科学计数法。<code>float</code> 类型的参数会显示 5 个字符。</p><p><code>datetime</code> 类型的值会转换为包含所有日期和时间字段的字符串（“YYYY.MM.DD hh:mm:ss”）。</p><p>枚举、单字节和双字节字符会作为整数输出。</p><p><code>color</code> 类型的值会显示为 “R,G,B” 三个分量组成的三元组，或者显示为颜色名称（如果在标准 Web 颜色列表中存在）。</p><p>在转换 <code>bool</code> 类型的值时，会使用字符串 “true” 或 “false”。</p><p><code>StringConcatenate</code> 函数返回结果字符串的长度。</p><p><code>StringConcatenate</code> 函数旨在从接收变量以外的其他源（变量、表达式）构建字符串。不建议通过调用 <code>StringConcatenate(variable, variable,...)</code> 将新的数据块连接到同一字符串上。这种函数调用没有经过优化，与 <code>+</code> 运算符和 <code>StringAdd</code> 函数相比，速度极慢。</p><p><code>StringAdd</code> 和 <code>StringConcatenate</code> 函数在 <code>StringAdd.mq5</code> 脚本中进行了测试，该脚本使用了 <code>PRTE</code> 宏以及上一节中的辅助函数 <code>StrOut</code>。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;r&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringConcatenate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, M_PI </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, clrBlue, PRICE_CLOSE));</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StrOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>执行该脚本后，日志中会显示以下内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>&#39;message&#39; [7] 0</span></span>
<span class="line"><span>StringAdd(s,r)=true</span></span>
<span class="line"><span>&#39;messager&#39; [8] 260</span></span>
<span class="line"><span>StringConcatenate(s,M_PI*100, ,clrBlue,PRICE_CLOSE)=true</span></span>
<span class="line"><span>&#39;314.1592653589793 clrBlue1&#39; [26] 260</span></span></code></pre></div><p>该脚本还包含头文件 <code>StringBenchmark.mqh</code>，其中有 <code>benchmark</code> 类。它为脚本中实现的派生类提供了一个框架，用于测量各种字符串添加方法的性能。特别是，它们确保使用 <code>+</code> 运算符和 <code>StringAdd</code> 函数添加字符串的性能是可比的。这部分内容留给读者自行学习。</p><p>此外，本书还附带了 <code>StringReserve.mq5</code> 脚本：它直观地比较了在使用或不使用缓冲区（<code>StringReserve</code>）的情况下添加字符串的速度。</p><h2 id="字符串比较" tabindex="-1">字符串比较 <a class="header-anchor" href="#字符串比较" aria-label="Permalink to &quot;字符串比较&quot;">​</a></h2><p>在 MQL5 中比较字符串时，可以使用标准的比较运算符，特别是 <code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>。所有这些运算符都是逐字符进行比较的，并且区分大小写。</p><p>每个字符都有一个 Unicode 编码，它是一个 <code>ushort</code> 类型的整数。相应地，首先比较两个字符串的第一个字符的编码，然后是第二个字符的编码，依此类推，直到出现第一个不匹配的字符或者到达其中一个字符串的末尾。</p><p>例如，字符串 “ABC” 小于 “abc”，因为在字符表中大写字母的编码低于相应小写字母的编码（在第一个字符上我们就得到 “A” &lt; “a”）。如果字符串开头的字符匹配，但其中一个字符串比另一个长，那么较长的字符串被认为更大（“ABCD” &gt; “ABC”）。</p><p>这样的字符串关系形成了字典序。当字符串 “A” 小于字符串 “B”（“A” &lt; “B”）时，就说 “A” 在 “B” 之前。</p><p>要熟悉字符编码，可以使用标准的 Windows 应用程序“字符映射表”。在其中，字符按编码递增的顺序排列。除了包含许多国家语言的通用 Unicode 表之外，还有代码页：具有单字节字符编码的 ANSI 标准表，不同语言或语言组的代码页是不同的。我们将在“处理符号和代码页”部分更详细地探讨这个问题。</p><p>字符表中编码从 0 到 127 的初始部分对于所有语言都是相同的。这部分内容如下表所示：</p><p><img src="`+h+`" alt=""></p><p><strong>ASCII 字符编码表</strong></p><p>要获取字符编码，取左边的十六进制数字（字符所在的行号）并加上顶部的数字（字符所在的列号）：结果是一个十六进制数。例如，对于 <code>!</code>，左边是 2，顶部是 1，这意味着字符编码是 <code>0x21</code>，即十进制的 33。</p><p>编码小于等于 32 的是控制码。其中，特别可以找到制表符（编码 <code>0x9</code>）、换行符（编码 <code>0xA</code>）和回车符（编码 <code>0xD</code>）。</p><p>在 Windows 文本文件中，连续的两个字符 <code>0xD</code> <code>0xA</code> 用于换行。我们在“字符类型”部分已经了解了相应的 MQL5 字面量：<code>0xA</code> 可以表示为 <code>&#39;\\n&#39;</code>，<code>0xD</code> 表示为 <code>&#39;\\r&#39;</code>。制表符 <code>0x9</code> 也有自己的表示形式：<code>&#39;\\t&#39;</code>。</p><p>MQL5 API 提供了 <code>StringCompare</code> 函数，它允许在比较字符串时禁用区分大小写的功能。</p><h3 id="int-stringcompare-const-string-string1-const-string-string2-const-bool-case-sensitive-true" tabindex="-1">int StringCompare(const string &amp;string1, const string &amp;string2, const bool case_sensitive = true) <a class="header-anchor" href="#int-stringcompare-const-string-string1-const-string-string2-const-bool-case-sensitive-true" aria-label="Permalink to &quot;int StringCompare(const string &amp;string1, const string &amp;string2, const bool case_sensitive = true)&quot;">​</a></h3><p>该函数比较两个字符串，并返回三个值之一：如果第一个字符串“大于”第二个字符串，则返回 <code>+1</code>；如果两个字符串“相等”，则返回 <code>0</code>；如果第一个字符串“小于”第二个字符串，则返回 <code>-1</code>。“大于”“小于”和“等于”的概念取决于 <code>case_sensitive</code> 参数。</p><p>当 <code>case_sensitive</code> 参数等于 <code>true</code>（这是默认值）时，比较是区分大小写的，大写字母被认为大于相同的小写字母。这与根据字符编码的标准字典序相反。</p><p>在区分大小写的情况下，<code>StringCompare</code> 函数使用的大写字母和小写字母的顺序与字典序不同。例如，我们知道 “A” &lt; “a” 这个关系是正确的，其中 <code>&lt;</code> 运算符是根据字符编码来判断的。因此，大写单词在假设的字典（数组）中应该出现在具有相同小写字母的单词之前。然而，当使用 <code>StringCompare(&quot;A&quot;, &quot;a&quot;)</code> 函数比较 “A” 和 “a” 时，我们得到 <code>+1</code>，这意味着 “A” 大于 “a”。因此，在排序后的字典中，以小写字母开头的单词将首先出现，只有在它们之后才会出现以大写字母开头的单词。</p><p>换句话说，该函数按字母顺序对字符串进行排序。此外，在区分大小写模式下，还有一个额外的规则：如果存在仅大小写不同的字符串，那么包含大写字母的字符串将跟随在具有相同小写字母的字符串之后（在单词的相同位置）。</p><p>如果 <code>case_sensitive</code> 参数等于 <code>false</code>，则字母不区分大小写，所以字符串 “A” 和 “a” 被认为是相等的，函数返回 <code>0</code>。</p><p>你可以使用 <code>StringCompare.mq5</code> 脚本检查 <code>StringCompare</code> 函数和比较运算符的不同比较结果。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringCompare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 1, 这意味着 &quot;A&quot; &gt; &quot;a&quot; (!)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringCompare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 0, 这意味着 &quot;A&quot; == &quot;a&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                      // false,   &quot;A&quot; &lt; &quot;a&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringCompare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;y&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // -1, 这意味着 &quot;x&quot; &lt; &quot;y&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;y&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                      // false,    &quot;x&quot; &lt; &quot;y&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在“函数模板”部分，我们创建了一个模板化的快速排序算法。让我们将它转换为一个模板类，并使用它进行几种排序选项：使用比较运算符，以及使用 <code>StringCompare</code> 函数（区分大小写和不区分大小写）。我们将新的 <code>QuickSortT</code> 类放在 <code>QuickSortT.mqh</code> 头文件中，并将其连接到测试脚本 <code>StringCompare.mq5</code>。</p><p>排序 API 几乎没有变化。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">typename T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">class QuickSortT</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Swap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   virtual </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Compare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a, T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QuickSort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> INT_MAX)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //if(!(array[i] &gt; array[end]))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Compare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[end]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">               Swap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array, i, pivot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>主要的区别是我们添加了一个虚方法 <code>Compare</code>，默认情况下它使用 <code>&gt;</code> 和 <code>&lt;</code> 运算符进行比较，并且像 <code>StringCompare</code> 一样返回 <code>+1</code>、<code>-1</code> 或 <code>0</code>。现在 <code>QuickSort</code> 方法中使用 <code>Compare</code> 方法而不是简单的比较，并且必须在子类中重写它，以便使用 <code>StringCompare</code> 函数或任何其他比较方式。</p><p>特别是，在 <code>StringCompare.mq5</code> 文件中，我们实现了以下从 <code>QuickSortT&lt;string&gt;</code> 派生的“比较器”类：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">class SortingStringCompare : public QuickSortT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> caseEnabled;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">public:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   SortingStringCompare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sensitivity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) :</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      caseEnabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sensitivity) { }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   virtual </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Compare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a, string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b) override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringCompare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b, caseEnabled);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>构造函数接收 1 个参数，该参数指定考虑（<code>true</code>）或忽略（<code>false</code>）大小写的字符串比较标志。字符串比较本身在重定义的虚方法 <code>Compare</code> 中完成，该方法使用给定的参数和设置调用 <code>StringCompare</code> 函数。</p><p>为了测试排序，我们需要一组包含大写和小写字母的字符串。我们可以自己生成：只需开发一个类，对于给定的集合长度（字符串），对预定义集合（字母表）中的字符进行排列（可重复）。例如，可以将范围限制在小写字母 “abcABC”，即三个首字母的大小写形式，并从它们生成所有可能的 2 个字符的字符串。</p><p><code>PermutationGenerator</code> 类在 <code>PermutationGenerator.mqh</code> 文件中提供，留给读者自行学习。这里我们仅展示它的公共接口。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">class PermutationGenerator</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> indices</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 集合每个位置上元素的索引，即</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   };</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 例如，字符串每个位置上 &quot;字母表&quot; 中字母的编号 </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PermutationGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   SimpleArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>创建生成器对象时，必须指定生成集合的长度 <code>length</code>（在我们的例子中，这将是字符串的长度，即 2）以及组成集合的不同元素的数量（在我们的例子中，这是唯一字母的数量，即 6）。使用这样的输入数据，应该得到 6 * 6 = 36 种字符串变体。</p><p>实际的生成过程由 <code>run</code> 方法执行。使用模板类 <code>SimpleArray</code> 来返回结果数组，我们在“方法模板”部分讨论过它。在这种情况下，它由 <code>result</code> 结构类型进行参数化。</p><p>生成器的调用以及根据从它接收到的排列数组（以所有可能字符串在每个位置上的字母索引的形式）实际创建字符串的操作在辅助函数 <code>GenerateStringList</code> 中进行。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenerateStringList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">symbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringLen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbols);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 字母表长度，唯一字符数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   PermutationGenerator </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(len, n);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   SimpleArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PermutationGenerator::Result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   ArrayResize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result, r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 遍历所有接收到的字符排列</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      string element;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 遍历字符串中的所有字符</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 将字母表中的一个字母（根据其索引）添加到字符串中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         element </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ShortToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">symbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i].indices[j]]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">      result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里我们使用了几个我们还不熟悉的函数（<code>ArrayResize</code>、<code>ShortToString</code>），但我们很快就会学到它们。目前，我们只需要知道 <code>ShortToString</code> 函数根据 <code>ushort</code> 类型的字符编码返回一个由单个字符组成的字符串。使用 <code>+=</code> 运算符，我们将这些单个字符组成的字符串连接成每个结果字符串。回想一下，为字符串定义了 <code>[]</code> 运算符，所以表达式 <code>symbols[k]</code> 将返回 <code>symbols</code> 字符串的第 <code>k</code> 个字符。当然，<code>k</code> 本身可以是一个整数表达式，这里 <code>r[i].indices[j]</code> 是指从 <code>r</code> 数组的第 <code>i</code> 个元素中读取字符串第 <code>j</code> 个位置的“字母表”字符的索引。</p><p>每个接收到的字符串都存储在数组参数 <code>result</code> 中。</p><p>让我们在 <code>OnStart</code> 函数中应用这些信息。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string messages</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   GenerateStringList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;abcABC&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, messages);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Original data[&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArraySize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messages), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;]:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messages);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Default case-sensitive sorting:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   QuickSortT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sorting;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   sorting.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QuickSort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messages);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messages);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;StringCompare case-insensitive sorting:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   SortingStringCompare </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">caseOff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   caseOff.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QuickSort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messages);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messages);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;StringCompare case-sensitive sorting:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   SortingStringCompare </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">caseOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   caseOn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QuickSort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messages);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messages);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>该脚本首先将所有字符串选项获取到 <code>messages</code> 数组中，然后以三种模式对其进行排序：使用内置的比较运算符，使用 <code>StringCompare</code> 函数的不区分大小写模式，以及使用 <code>StringCompare</code> 函数的区分大小写模式。</p><p>我们将得到以下日志输出：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>Original data[36]:</span></span>
<span class="line"><span>[ 0] &quot;aa&quot; &quot;ab&quot; &quot;ac&quot; &quot;aA&quot; &quot;aB&quot; &quot;aC&quot; &quot;ba&quot; &quot;bb&quot; &quot;bc&quot; &quot;bA&quot; &quot;bB&quot; &quot;bC&quot; &quot;ca&quot; &quot;cb&quot; &quot;cc&quot; &quot;cA&quot; &quot;cB&quot; &quot;cC&quot;</span></span>
<span class="line"><span>[18] &quot;Aa&quot; &quot;Ab&quot; &quot;Ac&quot; &quot;AA&quot; &quot;AB&quot; &quot;AC&quot; &quot;Ba&quot; &quot;Bb&quot; &quot;Bc&quot; &quot;BA&quot; &quot;BB&quot; &quot;BC&quot; &quot;Ca&quot; &quot;Cb&quot; &quot;Cc&quot; &quot;CA&quot; &quot;CB&quot; &quot;CC&quot;</span></span>
<span class="line"><span>Default case-sensitive sorting:</span></span>
<span class="line"><span>[ 0] &quot;AA&quot; &quot;AB&quot; &quot;AC&quot; &quot;Aa&quot; &quot;Ab&quot; &quot;Ac&quot; &quot;BA&quot; &quot;BB&quot; &quot;BC&quot; &quot;Ba&quot; &quot;Bb&quot; &quot;Bc&quot; &quot;CA&quot; &quot;CB&quot; &quot;CC&quot; &quot;Ca&quot; &quot;Cb&quot; &quot;Cc&quot;</span></span>
<span class="line"><span>[18] &quot;aA&quot; &quot;aB&quot; &quot;aC&quot; &quot;aa&quot; &quot;ab&quot; &quot;ac&quot; &quot;bA&quot; &quot;bB&quot; &quot;bC&quot; &quot;ba&quot; &quot;bb&quot; &quot;bc&quot; &quot;cA&quot; &quot;cB&quot; &quot;cC&quot; &quot;ca&quot; &quot;cb&quot; &quot;cc&quot;</span></span>
<span class="line"><span>StringCompare case-insensitive sorting:</span></span>
<span class="line"><span>[ 0] &quot;AA&quot; &quot;Aa&quot; &quot;aA&quot; &quot;aa&quot; &quot;AB&quot; &quot;aB&quot; &quot;Ab&quot; &quot;ab&quot; &quot;aC&quot; &quot;AC&quot; &quot;Ac&quot; &quot;ac&quot; &quot;BA&quot; &quot;Ba&quot; &quot;bA&quot; &quot;ba&quot; &quot;BB&quot; &quot;bB&quot;</span></span>
<span class="line"><span>[18] &quot;Bb&quot; &quot;bb&quot; &quot;bC&quot; &quot;BC&quot; &quot;Bc&quot; &quot;bc&quot; &quot;CA&quot; &quot;Ca&quot; &quot;cA&quot; &quot;ca&quot; &quot;CB&quot; &quot;cB&quot; &quot;Cb&quot; &quot;cb&quot; &quot;cC&quot; &quot;CC&quot; &quot;Cc&quot; &quot;cc&quot;</span></span>
<span class="line"><span>StringCompare case-sensitive sorting:</span></span>
<span class="line"><span>[ 0] &quot;aa&quot; &quot;aA&quot; &quot;Aa&quot; &quot;AA&quot; &quot;ab&quot; &quot;aB&quot; &quot;Ab&quot; &quot;AB&quot; &quot;ac&quot; &quot;aC&quot; &quot;Ac&quot; &quot;AC&quot; &quot;ba&quot; &quot;bA&quot; &quot;Ba&quot; &quot;BA&quot; &quot;bb&quot; &quot;bB&quot;</span></span>
<span class="line"><span>[18] &quot;Bb&quot; &quot;BB&quot; &quot;bc&quot; &quot;bC&quot; &quot;Bc&quot; &quot;BC&quot; &quot;ca&quot; &quot;cA&quot; &quot;Ca&quot; &quot;CA&quot; &quot;cb&quot; &quot;cB&quot; &quot;Cb&quot; &quot;CB&quot; &quot;cc&quot; &quot;cC&quot; &quot;Cc&quot; &quot;CC&quot;</span></span></code></pre></div><p>输出显示了这三种模式的差异。</p><h2 id="更改字符大小写和去除空白字符" tabindex="-1">更改字符大小写和去除空白字符 <a class="header-anchor" href="#更改字符大小写和去除空白字符" aria-label="Permalink to &quot;更改字符大小写和去除空白字符&quot;">​</a></h2><p>处理文本时常常会用到一些标准操作，比如将所有字符转换为大写或小写，以及去除字符串开头或结尾处多余的空白字符（例如空格）。为此，MQL5 API 提供了四个相应的函数。这些函数都会在原位修改字符串，也就是说，直接在已分配的可用缓冲区中进行修改。</p><p>所有这些函数的输入参数都是对字符串的引用，即只能将变量（而不是表达式）传递给它们，并且不能是常量变量，因为这些函数需要修改参数。</p><p>对所有函数进行测试的脚本会在相关描述之后给出。</p><h3 id="bool-stringtolower-string-variable" tabindex="-1">bool StringToLower(string &amp;variable) <a class="header-anchor" href="#bool-stringtolower-string-variable" aria-label="Permalink to &quot;bool StringToLower(string &amp;variable)&quot;">​</a></h3><h3 id="bool-stringtoupper-string-variable" tabindex="-1">bool StringToUpper(string &amp;variable) <a class="header-anchor" href="#bool-stringtoupper-string-variable" aria-label="Permalink to &quot;bool StringToUpper(string &amp;variable)&quot;">​</a></h3><p>这些函数将指定字符串的所有字符转换为相应的大小写：<code>StringToLower</code> 转换为小写字母，<code>StringToUpper</code> 转换为大写字母。这包括对 Windows 系统级别支持的各种国家语言的处理。</p><p>如果操作成功，函数返回 <code>true</code>；如果出错，则返回 <code>false</code>。</p><h3 id="int-stringtrimleft-string-variable" tabindex="-1">int StringTrimLeft(string &amp;variable) <a class="header-anchor" href="#int-stringtrimleft-string-variable" aria-label="Permalink to &quot;int StringTrimLeft(string &amp;variable)&quot;">​</a></h3><h3 id="int-stringtrimright-string-variable" tabindex="-1">int StringTrimRight(string &amp;variable) <a class="header-anchor" href="#int-stringtrimright-string-variable" aria-label="Permalink to &quot;int StringTrimRight(string &amp;variable)&quot;">​</a></h3><p><code>StringTrimLeft</code> 函数会去除字符串开头的回车符（<code>&#39;\\r&#39;</code>）、换行符（<code>&#39;\\n&#39;</code>）、空格（<code>&#39; &#39;</code>）、制表符（<code>&#39;\\t&#39;</code>）以及其他一些不可显示的字符；<code>StringTrimRight</code> 函数则会去除字符串结尾的这些字符。如果字符串内部（在可显示字符之间）存在空白字符，它们将被保留。</p><p>函数返回去除的字符数量。</p><p><code>StringModify.mq5</code> 文件演示了上述函数的操作：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">AbCdE F1  &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // ↑        ↑  ↑</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // |        |  └2个空格</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // |        └空格</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // └2个空格和制表符</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToLower</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // &#39;true&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // &#39;  \\tabcde f1  &#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToUpper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // &#39;true&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // &#39;  \\tABCDE F1  &#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringTrimLeft</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // &#39;3&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // &#39;ABCDE F1  &#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringTrimRight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &#39;2&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // &#39;ABCDE F1&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringTrimRight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &#39;0&#39;  (没有其他可删除的内容了)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // &#39;ABCDE F1&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                               //       ↑</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                               //       └内部的空格被保留</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string russian </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Russian text&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToUpper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(russian));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // &#39;true&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(russian);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // &#39;RUSSIAN TEXT&#39;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string german </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;straßenführung&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToUpper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(german));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // &#39;true&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(german);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // &#39;STRAßENFÜHRUNG&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="查找、替换和提取字符串片段" tabindex="-1">查找、替换和提取字符串片段 <a class="header-anchor" href="#查找、替换和提取字符串片段" aria-label="Permalink to &quot;查找、替换和提取字符串片段&quot;">​</a></h2><p>在处理字符串时，最常用的操作或许就是查找和替换片段，以及提取片段。在这部分内容中，我们会学习 MQL5 API 里能够解决这些问题的函数。这些函数的使用示例都汇总在 <code>StringFindReplace.mq5</code> 文件里。</p><h3 id="int-stringfind-string-value-string-wanted-int-start-0" tabindex="-1">int StringFind(string value, string wanted, int start = 0) <a class="header-anchor" href="#int-stringfind-string-value-string-wanted-int-start-0" aria-label="Permalink to &quot;int StringFind(string value, string wanted, int start = 0)&quot;">​</a></h3><p>此函数从 <code>start</code> 位置开始，在字符串 <code>value</code> 里查找子字符串 <code>wanted</code>。若找到该子字符串，函数会返回其起始位置，字符串中的字符编号从 0 开始；若未找到，则返回 -1。这两个参数都是按值传递的，这意味着不仅可以处理变量，还能处理计算的中间结果（表达式、函数调用）。</p><p>搜索是基于字符的严格匹配进行的，也就是区分大小写。若要进行不区分大小写的搜索，就得先使用 <code>StringToLower</code> 或 <code>StringToUpper</code> 把源字符串转换为统一的大小写。</p><p>我们尝试用 <code>StringFind</code> 函数统计文本中所需子字符串出现的次数。为此，我们编写一个辅助函数 <code>CountSubstring</code>，它会在循环里调用 <code>StringFind</code>，并逐步移动最后一个参数 <code>start</code> 中的搜索起始位置。只要能找到子字符串的新出现位置，循环就会继续执行。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CountSubstring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wanted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 由于循环开始时会自增，所以先回退一个位置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cursor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cursor;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 从下一个位置继续搜索</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 获取下一个子字符串的位置，若没有匹配则返回 -1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      cursor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringFind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, wanted, cursor);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cursor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>需要注意的是，上述实现查找的子字符串是可以重叠的。这是因为在开始查找下一个出现位置之前，当前位置会增加 1（<code>++cursor</code>）。所以，当在字符串 &quot;AAAAA&quot; 中搜索子字符串 &quot;AAA&quot; 时，会找到 3 个匹配项。搜索的技术要求可能和这种行为有所不同。特别是，有一种做法是在之前找到的片段结束位置之后继续搜索。在这种情况下，就需要修改算法，让 <code>cursor</code> 以等于 <code>StringLen(wanted)</code> 的步长移动。</p><p>我们在 <code>OnStart</code> 函数中对不同的参数调用 <code>CountSubstring</code> 函数。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string abracadabra </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ABRACADABRA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CountSubstring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(abracadabra, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 5</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CountSubstring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(abracadabra, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;D&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CountSubstring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(abracadabra, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;E&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CountSubstring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(abracadabra, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ABRA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="int-stringreplace-string-variable-const-string-wanted-const-string-replacement" tabindex="-1">int StringReplace(string &amp;variable, const string wanted, const string replacement) <a class="header-anchor" href="#int-stringreplace-string-variable-const-string-wanted-const-string-replacement" aria-label="Permalink to &quot;int StringReplace(string &amp;variable, const string wanted, const string replacement)&quot;">​</a></h3><p>该函数会把字符串 <code>variable</code> 中所有找到的 <code>wanted</code> 子字符串替换成 <code>replacement</code> 子字符串。</p><p>函数会返回替换的次数，若出错则返回 -1。可以通过调用 <code>GetLastError</code> 函数获取错误代码。特别是，可能会出现内存不足的错误，或者将未初始化的字符串（<code>NULL</code>）作为参数使用。<code>variable</code> 和 <code>wanted</code> 参数必须是长度不为零的字符串。</p><p>若将空字符串 <code>&quot;&quot;</code> 作为 <code>replacement</code> 参数，那么所有 <code>wanted</code> 的出现位置都会从原始字符串中直接删除。</p><p>若没有进行替换，函数的结果为 0。</p><p>我们通过 <code>StringFindReplace.mq5</code> 示例来查看 <code>StringReplace</code> 函数的实际运行情况。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string abracadabra </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ABRACADABRA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(abracadabra, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ABRA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-ABRA-&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(abracadabra, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;CAD&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(abracadabra, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;XYZ&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // -1, 错误</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetLastError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 5040, ERR_WRONG_STRING_PARAMETER</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(abracadabra);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                              // &#39;-ABRA---ABRA-&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span></code></pre></div><p>接下来，我们使用 <code>StringReplace</code> 函数尝试解决在处理任意文本时遇到的一个任务。我们要确保某个分隔符字符始终作为单个字符使用，也就是多个这样的字符序列必须替换为一个。通常，这指的是单词之间的空格，但在技术数据中可能会有其他分隔符。我们针对分隔符 <code>-</code> 来测试我们的程序。</p><p>我们把这个算法实现为一个单独的函数 <code>NormalizeSeparatorsByReplace</code>：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NormalizeSeparatorsByReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ushort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> separator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string single </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ShortToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(separator);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string twin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> replaced </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      replaced </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, twin, single);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(replaced </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> replaced;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(replaced </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>该程序会在 <code>do - while</code> 循环中尝试将两个分隔符的序列替换为一个，只要 <code>StringReplace</code> 函数返回的值大于 0（即还有需要替换的内容），循环就会继续。函数会返回总共进行的替换次数。</p><p>在 <code>OnStart</code> 函数中，我们对包含多个 <code>-</code> 字符的字符串进行“清理”。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string copy1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> abracadabra </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string copy2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> copy1;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(copy1);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                    // &#39;--ABRA---ABRA--&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NormalizeSeparatorsByReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(copy1, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 4</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(copy1);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                    // &#39;-ABRA-ABRA-&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(copy1, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(copy1);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                    // &#39;ABRAABRA&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span></code></pre></div><h3 id="int-stringsplit-const-string-value-const-ushort-separator-string-result" tabindex="-1">int StringSplit(const string value, const ushort separator, string &amp;result[]) <a class="header-anchor" href="#int-stringsplit-const-string-value-const-ushort-separator-string-result" aria-label="Permalink to &quot;int StringSplit(const string value, const ushort separator, string &amp;result[])&quot;">​</a></h3><p>此函数会根据给定的分隔符将传入的字符串 <code>value</code> 分割成多个子字符串，并将它们存入 <code>result</code> 数组。函数会返回得到的子字符串的数量，若出错则返回 -1。</p><p>若字符串中没有分隔符，数组将只有一个元素，其值等于整个字符串。</p><p>若源字符串为空或为 <code>NULL</code>，函数将返回 0。</p><p>为了演示这个函数的操作，我们用 <code>StringSplit</code> 以一种新的方式解决之前的问题。为此，我们编写函数 <code>NormalizeSeparatorsBySplit</code>。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NormalizeSeparatorsBySplit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ushort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> separator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string single </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ShortToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(separator);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string elements</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringSplit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, separator, elements);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 调试用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   StringFill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 结果将替换原始字符串</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 空字符串表示分隔符，只有在前一个字符串不为空（即也不是分隔符）时才添加</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">elements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> elements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      else</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 其他所有字符串按原样连接</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> elements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当源文本中分隔符连续出现时，<code>StringSplit</code> 输出数组中对应的元素会是一个空字符串 <code>&quot;&quot;</code>。此外，如果文本以分隔符开头，数组开头会有一个空字符串；如果文本以分隔符结尾，数组末尾会有一个空字符串。</p><p>要得到“清理”后的文本，需要将数组中所有非空字符串添加进来，并用单个分隔符字符将它们“粘合”在一起。而且，只有那些前一个数组元素也不为空的空元素才应转换为分隔符。</p><p>当然，这只是实现此功能的一种可能方式。我们在 <code>OnStart</code> 函数中对其进行测试。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string copy2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> abracadabra </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;-&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // &#39;--ABRA---ABRA--&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NormalizeSeparatorsBySplit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(copy2, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 8</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 函数内部的分割数组调试输出:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;&quot;     &quot;&quot;     &quot;ABRA&quot; &quot;&quot;     &quot;&quot;     &quot;ABRA&quot; &quot;&quot;     &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(copy2);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                    // &#39;-ABRA-ABRA-&#39;</span></span></code></pre></div><h3 id="string-stringsubstr-string-value-int-start-int-length-1" tabindex="-1">string StringSubstr(string value, int start, int length = -1) <a class="header-anchor" href="#string-stringsubstr-string-value-int-start-int-length-1" aria-label="Permalink to &quot;string StringSubstr(string value, int start, int length = -1)&quot;">​</a></h3><p>该函数从传入的文本 <code>value</code> 中提取从指定位置 <code>start</code> 开始、长度为 <code>length</code> 的子字符串。起始位置可以是从 0 到字符串长度减 1。若 <code>length</code> 为 -1 或者大于从 <code>start</code> 到字符串末尾的字符数，将完整提取字符串的剩余部分。</p><p>若参数不正确，函数会返回一个子字符串或空字符串。</p><p>我们来看它是如何工作的。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringSubstr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ABRACADABRA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // &#39;CAD&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringSubstr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ABRACADABRA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // &#39;CADABRA&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringSubstr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ABRACADABRA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // &#39;CADABRA&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringSubstr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ABRACADABRA&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // &#39;&#39;</span></span></code></pre></div><h3 id="处理符号和代码页" tabindex="-1">处理符号和代码页 <a class="header-anchor" href="#处理符号和代码页" aria-label="Permalink to &quot;处理符号和代码页&quot;">​</a></h3><p>由于字符串是由字符组成的，有时在字符的整数编码层面上操作字符串中的单个字符或字符组是必要的，或者会更加方便。例如，需要逐个读取或替换字符，或者将它们转换为整数编码数组，以便通过通信协议传输，或者传递给动态链接库（DLL）的第三方编程接口。在所有这些情况下，将字符串作为文本传递可能会遇到各种困难：</p><ul><li>确保正确的编码（编码方式有很多种，具体的选择取决于操作系统的区域设置、程序设置、与之通信的服务器的配置等等）</li><li>将本国语言字符从本地文本编码转换为 Unicode 编码，反之亦然</li><li>以统一的方式进行内存的分配和释放</li></ul><p>使用整数编码数组（实际上，这种使用方式产生的是字符串的二进制表示，而非文本表示）可以简化这些问题。</p><p>MQL5 API 提供了一组函数，用于在考虑编码特性的情况下操作单个字符或字符组。</p><p>MQL5 中的字符串包含采用双字节 Unicode 编码的字符。这在一个（非常庞大的）字符表中为各种不同的国家字母表提供了通用支持。两个字节可以对 65535 个元素进行编码。</p><p>默认的字符类型是 <code>ushort</code>。然而，如果有必要，字符串可以转换为特定语言编码的单字节 <code>uchar</code> 字符序列。这种转换可能会伴随一些信息的丢失（特别是，不在本地化字符表中的字母可能会“丢失”变音符号，甚至“变成”某种替代字符：根据上下文的不同，它可能会有不同的显示方式，但通常显示为 <code>?</code> 或一个方块字符）。</p><p>为了避免处理可能包含任意字符的文本时出现问题，建议始终使用 Unicode。如果某些要与您的 MQL 程序集成的外部服务或程序不支持 Unicode，或者如果文本从一开始就只打算存储有限的一组字符（例如，仅包含数字和拉丁字母），则可以例外。</p><p>在转换为单字节字符或从单字节字符转换时，MQL5 API 默认使用 ANSI 编码，具体取决于当前的 Windows 设置。不过，开发人员可以指定不同的代码表（请参阅后面的函数 <code>CharArrayToString</code>、<code>StringToCharArray</code>）。</p><p>下面描述的函数的使用示例在 <code>StringSymbols.mq5</code> 文件中给出。</p><h3 id="bool-stringsetcharacter-string-variable-int-position-ushort-character" tabindex="-1">bool StringSetCharacter(string &amp;variable, int position, ushort character) <a class="header-anchor" href="#bool-stringsetcharacter-string-variable-int-position-ushort-character" aria-label="Permalink to &quot;bool StringSetCharacter(string &amp;variable, int position, ushort character)&quot;">​</a></h3><p>该函数将字符串 <code>variable</code> 中 <code>position</code> 位置的字符更改为传入的 <code>character</code> 值。位置编号必须在 0 到字符串长度（<code>StringLen</code>）减 1 之间。</p><p>如果要写入的字符为 0，它将指定一个新的行结尾（充当终止零），即字符串的长度变为等于 <code>position</code>。为字符串分配的缓冲区大小不会改变。</p><p>如果 <code>position</code> 参数等于字符串的长度，并且要写入的字符不等于 0，那么该字符将被添加到字符串中，其长度增加 1。这等同于表达式：<code>variable += ShortToString(character)</code>。</p><p>函数成功完成时返回 <code>true</code>，出错时返回 <code>false</code>。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string numbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;0123456789&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringSetCharacter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 在第 7 个字符处截断</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                             // 0123456</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringSetCharacter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringLen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 添加 &#39;*&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                             // 0123456*</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="ushort-stringgetcharacter-string-value-int-position" tabindex="-1">ushort StringGetCharacter(string value, int position) <a class="header-anchor" href="#ushort-stringgetcharacter-string-value-int-position" aria-label="Permalink to &quot;ushort StringGetCharacter(string value, int position)&quot;">​</a></h3><p>该函数返回字符串中指定位置 <code>position</code> 处的字符编码。位置编号必须在 0 到字符串长度（<code>StringLen</code>）减 1 之间。如果出错，函数将返回 0。</p><p>该函数等同于使用 <code>[]</code> 运算符进行编写：<code>value[position]</code>。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string numbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;0123456789&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringGetCharacter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numbers, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 53 = 字符 &#39;5&#39; 的编码</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">numbers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                          // 53 - 结果相同</span></span></code></pre></div><h3 id="string-chartostring-uchar-code" tabindex="-1">string CharToString(uchar code) <a class="header-anchor" href="#string-chartostring-uchar-code" aria-label="Permalink to &quot;string CharToString(uchar code)&quot;">​</a></h3><p>该函数将字符的 ANSI 编码转换为单字符字符串。根据设置的 Windows 代码页，编码的上半部分（大于 127）可以生成不同的字母（字符样式不同，但编码保持不变）。例如，代码为 <code>0xB8</code>（十进制 184）的符号在西欧语言中表示软音符（下钩），而在俄语中这里是字母 <code>ё</code>。再举个例子：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CharToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // &quot;©&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CharToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">E6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // &quot;æ&quot;, &quot;ж&quot;, 或其他字符</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                           // 取决于您的 Windows 区域设置</span></span></code></pre></div><h3 id="string-shorttostring-ushort-code" tabindex="-1">string ShortToString(ushort code) <a class="header-anchor" href="#string-shorttostring-ushort-code" aria-label="Permalink to &quot;string ShortToString(ushort code)&quot;">​</a></h3><p>该函数将字符的 Unicode 编码转换为单字符字符串。对于 <code>code</code> 参数，可以使用字面值或整数。例如，希腊大写字母“西格玛”（数学公式中的求和符号）可以指定为 <code>0x3A3</code> 或 <code>&#39;Σ&#39;</code>。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ShortToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3A3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &quot;Σ&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ShortToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Σ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // &quot;Σ&quot;</span></span></code></pre></div><h3 id="int-stringtoshortarray-const-string-text-ushort-array-int-start-0-int-count-1" tabindex="-1">int StringToShortArray(const string text, ushort &amp;array[], int start = 0, int count = -1) <a class="header-anchor" href="#int-stringtoshortarray-const-string-text-ushort-array-int-start-0-int-count-1" aria-label="Permalink to &quot;int StringToShortArray(const string text, ushort &amp;array[], int start = 0, int count = -1)&quot;">​</a></h3><p>该函数将字符串转换为 <code>ushort</code> 字符编码序列，并将其复制到数组中的指定位置：从编号为 <code>start</code> 的元素开始（默认为 0，即数组的开头），数量为 <code>count</code>。</p><p>请注意：<code>start</code> 参数指的是数组中的位置，而不是字符串中的位置。如果要转换字符串的一部分，必须首先使用 <code>StringSubstr</code> 函数提取它。</p><p>如果 <code>count</code> 参数等于 -1（或 <code>WHOLE_ARRAY</code>），则会复制直到字符串末尾的所有字符（包括终止零），或者如果数组是固定大小的，则根据数组的大小复制字符。</p><p>对于动态数组，如果需要，它的大小将自动增加。如果动态数组的大小大于字符串的长度，则数组的大小不会减小。</p><p>要复制没有终止零的字符，必须显式调用 <code>StringLen</code> 作为 <code>count</code> 参数。否则，数组的长度将比字符串的长度多 1（并且最后一个元素为 0）。</p><p>函数返回复制的字符数。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ushort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, array2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 动态数组 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ushort</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 固定大小数组 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string alphabet </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ABCDEАБВГД&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复制并包含终止符 &#39;0&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToShortArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(alphabet, array1));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 11</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array1);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 65   66   67   68   69 1040 1041 1042 1043 1044    0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复制且不包含终止符 &#39;0&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToShortArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(alphabet, array2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringLen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(alphabet)));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 10</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array2);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 65   66   67   68   69 1040 1041 1042 1043 1044</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复制到固定数组 </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToShortArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(alphabet, text));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 5</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 65 66 67 68 69</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复制超出数组之前的限制 </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// (元素 [11-19] 将是随机的)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToShortArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(alphabet, array2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 11</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array2);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">[ 0]    65    66    67    68    69  1040  1041  1042</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         1043  1044     0     0     0     0     0 14245</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">[16] 15102 37754 48617 54228    65    66    67    68</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           69  1040  1041  1042  1043  1044     0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span></code></pre></div><p>请注意，如果复制的位置超出了数组的大小，那么中间的元素将被分配但不会初始化。因此，它们可能包含随机数据（上面以黄色突出显示）。</p><h3 id="string-shortarraytostring-const-ushort-array-int-start-0-int-count-1" tabindex="-1">string ShortArrayToString(const ushort &amp;array[], int start = 0, int count = -1) <a class="header-anchor" href="#string-shortarraytostring-const-ushort-array-int-start-0-int-count-1" aria-label="Permalink to &quot;string ShortArrayToString(const ushort &amp;array[], int start = 0, int count = -1)&quot;">​</a></h3><p>该函数将包含字符编码的数组的一部分转换为字符串。数组元素的范围分别由参数 <code>start</code> 和 <code>count</code> 设置，即起始位置和数量。<code>start</code> 参数必须在 0 到数组中元素数量减 1 之间。如果 <code>count</code> 等于 -1（或 <code>WHOLE_ARRAY</code>），则会复制直到数组末尾的所有元素，或者直到遇到第一个零。</p><p>使用 <code>StringSymbols.mq5</code> 中的相同示例，我们尝试将数组转换为 <code>array2</code> 字符串，其大小为 30。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ShortArrayToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &quot;ABCDEАБВГД&quot;, 这里可能会出现额外的随机字符</span></span></code></pre></div><p>因为在 <code>array2</code> 数组中，字符串 &quot;ABCDEABCD&quot; 被复制了两次，具体来说，第一次复制到了数组的开头，第二次复制到了偏移量为 20 的位置，所以中间的字符将是随机的，并且可能会形成一个比我们预期更长的字符串。</p><h3 id="int-stringtochararray-const-string-text-uchar-array-int-start-0-int-count-1-uint-codepage-cp-acp" tabindex="-1">int StringToCharArray(const string text, uchar &amp;array[], int start = 0, int count = -1, uint codepage = CP_ACP) <a class="header-anchor" href="#int-stringtochararray-const-string-text-uchar-array-int-start-0-int-count-1-uint-codepage-cp-acp" aria-label="Permalink to &quot;int StringToCharArray(const string text, uchar &amp;array[], int start = 0, int count = -1, uint codepage = CP_ACP)&quot;">​</a></h3><p>该函数将文本字符串转换为单字节字符序列，并将其复制到数组中的指定位置：从编号为 <code>start</code> 的元素开始（默认为 0，即数组的开头），数量为 <code>count</code>。复制过程将字符从 Unicode 转换为选定的代码页 <code>codepage</code> — 默认情况下为 <code>CP_ACP</code>，这意味着 Windows 操作系统的语言（下面会详细介绍）。</p><p>如果 <code>count</code> 参数等于 -1（或 <code>WHOLE_ARRAY</code>），则会复制直到字符串末尾的所有字符（包括终止零），或者如果数组是固定大小的，则根据数组的大小复制字符。</p><p>对于动态数组，如果需要，它的大小将自动增加。如果动态数组的大小大于字符串的长度，则数组的大小不会减小。</p><p>要复制没有终止零的字符，必须显式调用 <code>StringLen</code> 作为 <code>count</code> 参数。</p><p>函数返回复制的字符数。</p><p>有关 <code>codepage</code> 参数的有效代码页列表，请参阅文档。以下是一些广泛使用的 ANSI 代码页：</p><table tabindex="0"><thead><tr><th>语言</th><th>代码</th></tr></thead><tbody><tr><td>中欧拉丁语</td><td>1250</td></tr><tr><td>西里尔语</td><td>1251</td></tr><tr><td>西欧拉丁语</td><td>1252</td></tr><tr><td>希腊语</td><td>1253</td></tr><tr><td>土耳其语</td><td>1254</td></tr><tr><td>希伯来语</td><td>1255</td></tr><tr><td>阿拉伯语</td><td>1256</td></tr><tr><td>波罗的海语</td><td>1257</td></tr></tbody></table><p>因此，在使用西欧语言的计算机上，<code>CP_ACP</code> 为 1252，例如，在使用俄语的计算机上，它为 1251。</p><p>在转换过程中，一些字符可能会在信息丢失的情况下进行转换，因为 Unicode 表比 ANSI 表大得多（每个 ANSI 代码表有 256 个字符）。</p><p>在所有 <code>CP_***</code> 常量中，<code>CP_UTF8</code> 具有特别重要的意义。它通过可变长度编码允许正确保留本国字符：生成的数组仍然存储字节，但每个本国字符可以跨越多个字节，并以特殊格式书写。因此，数组的长度可能会明显大于字符串的长度。UTF-8 编码在互联网和各种软件中被广泛使用。顺便说一下，UTF 代表 Unicode 转换格式，还有其他变体，特别是 UTF-16 和 UTF-32。</p><p>在熟悉了“反向”函数 <code>CharArrayToString</code> 之后，我们将考虑 <code>StringToCharArray</code> 的示例：它们的工作必须结合起来进行演示。</p><h3 id="string-chararraytostring-const-uchar-array-int-start-0-int-count-1-uint-codepage-cp-acp" tabindex="-1">string CharArrayToString(const uchar &amp;array[], int start = 0, int count = -1, uint codepage = CP_ACP) <a class="header-anchor" href="#string-chararraytostring-const-uchar-array-int-start-0-int-count-1-uint-codepage-cp-acp" aria-label="Permalink to &quot;string CharArrayToString(const uchar &amp;array[], int start = 0, int count = -1, uint codepage = CP_ACP)&quot;">​</a></h3><p>该函数将字节数组或其一部分转换为字符串。数组必须包含特定编码的字符。数组元素的范围分别由参数 <code>start</code> 和 <code>count</code> 设置，即起始位置和数量。<code>start</code> 参数必须在 0 到数组中元素数量之间。当 <code>count</code> 等于 -1（或 <code>WHOLE_ARRAY</code>）时，会复制直到数组末尾的所有元素，或者直到遇到第一个零。</p><p>让我们看看 <code>StringToCharArray</code> 和 <code>CharArrayToString</code> 函数在不同代码页设置下处理不同国家字符时的工作情况。为此准备了一个测试脚本 <code>StringCodepages.mq5</code>。</p><p>将使用两行文本作为测试对象 — 一行是俄语，一行是德语：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Locales&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   uchar bytes1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, bytes2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string german </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;straßenführung&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   string russian </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Russian text&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ...</span></span></code></pre></div><p>我们将把它们复制到数组 <code>bytes1</code> 和 <code>bytes2</code> 中，然后再将它们恢复为字符串。</p><p>首先，使用欧洲代码页 1252 转换德语文本。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(german, bytes1, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1252</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes1);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 115 116 114  97 223 101 110 102 252 104 114 117 110 103   0</span></span></code></pre></div><p>在欧洲版本的 Windows 上，这等同于使用默认参数调用更简单的函数，因为在那里 <code>CP_ACP = 1252</code>：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(german, bytes1);</span></span></code></pre></div><p>然后通过以下调用从数组中恢复文本，并确保与原始文本匹配：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CharArrayToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes1, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1252</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// CharArrayToString(bytes1,0,WHOLE_ARRAY,1252)=&#39;straßenführung&#39;</span></span></code></pre></div><p>现在让我们尝试用相同的欧洲编码转换俄语文本（或者在 <code>CP_ACP</code> 设置为 1252 作为默认代码页的 Windows 环境中调用 <code>StringToCharArray(english, bytes2)</code>）：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(russian, bytes2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1252</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes2);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 63 63 63 63 63 63 63 32 63 63 63 63 63  0</span></span></code></pre></div><p>在这里已经可以看到转换过程中出现了问题，因为 1252 代码页中没有西里尔字符。从数组恢复字符串清楚地显示了问题的本质：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CharArrayToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1252</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// CharArrayToString(bytes2,0,WHOLE_ARRAY,1252)=&#39;??????? ?????&#39;</span></span></code></pre></div><p>让我们在一个假设的俄语环境中重复这个实验，即我们将使用西里尔语代码页 1251 来回转换这两个字符串。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(russian, bytes2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1251</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在俄语 Windows 上，此调用等同于更简单的调用</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// StringToCharArray(russian, bytes2);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 因为 CP_ACP = 1251</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes2);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 这次字符编码是有意义的</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 208 243 241 241 234 232 233  32 210 229 234 241 242   0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 恢复字符串并确保与原始字符串匹配</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CharArrayToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1251</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// CharArrayToString(bytes2,0,WHOLE_ARRAY,1251)=&#39;Русский Текст&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对于德语文本...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(german, bytes1, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1251</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes1);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 115 116 114  97  63 101 110 102 117 104 114 117 110 103   0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果我们将 bytes1 的此内容与之前的版本进行比较，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 很容易看出有几个字符受到了影响；情况如下：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 115 116 114  97 223 101 110 102 252 104 114 117 110 103   0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 恢复字符串以直观地查看差异：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CharArrayToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes1, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1251</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// CharArrayToString(bytes1,0,WHOLE_ARRAY,1251)=&#39;stra?enfuhrung&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 特定的德语字符已损坏</span></span></code></pre></div><p>因此，单字节编码的脆弱性显而易见。</p><p>最后，让我们为两个测试字符串启用 <code>CP_UTF8</code> 编码。这部分示例无论 Windows 设置如何都能稳定工作。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(german, bytes1, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, CP_UTF8);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes1);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 115 116 114  97 195 159 101 110 102 195 188 104 114 117 110 103   0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CharArrayToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes1, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, CP_UTF8));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// CharArrayToString(bytes1,0,WHOLE_ARRAY,CP_UTF8)=&#39;straßenführung&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StringToCharArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(russian, bytes2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, CP_UTF8);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes2);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 208 160 209 131 209 129 209 129 208 186 208 184 208 185</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//  32 208 162 208 181 208 186 209 129 209 130   0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CharArrayToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bytes2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, WHOLE_ARRAY, CP_UTF8));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// CharArrayToString(bytes2,0,WHOLE_ARRAY,CP_UTF8)=&#39;Русский Текст&#39;</span></span></code></pre></div><p>请注意，两个 UTF-8 编码的字符串所需的数组都比 ANSI 编码的数组大。此外，俄语字符串的数组实际上变长了两倍，因为现在所有字母都占用 2 个字节。有兴趣的人可以在公开资源中找到 UTF-8 编码具体工作方式的详细信息。在本书的背景下，对我们来说重要的是 MQL5 API 提供了现成的函数来进行相关操作。</p><p>通过这些函数，开发者可以更灵活地处理字符串中的字符，无论是进行字符级别的修改、提取字符编码，还是在不同编码之间进行转换，都能找到合适的工具来满足需求。在实际编程中，根据具体的应用场景和数据来源，正确选择和使用这些函数对于确保字符串处理的正确性和高效性至关重要。同时，了解不同编码的特点和适用范围，也有助于避免因编码问题导致的数据丢失或显示错误等问题。</p><h2 id="通用格式化数据输出为字符串" tabindex="-1">通用格式化数据输出为字符串 <a class="header-anchor" href="#通用格式化数据输出为字符串" aria-label="Permalink to &quot;通用格式化数据输出为字符串&quot;">​</a></h2><p>在生成要显示给用户、保存到文件或通过互联网发送的字符串时，可能需要在其中包含多个不同类型变量的值。 可以通过将所有变量显式转换为（字符串）类型并将得到的字符串相加来解决此问题，但在这种情况下，MQL 代码指令会很长且难以理解。 使用 <code>StringConcatenate</code> 函数可能会更方便，但这种方法并不能完全解决问题。</p><p>事实上，一个字符串通常不仅包含变量，还包含一些文本插入内容，这些内容充当连接纽带，并为整体消息提供正确的结构。 结果是格式化文本片段与变量混合在一起。 这种代码很难维护，这与编程中一个著名的原则相悖：内容与表示的分离。</p><p>针对这个问题有一个特殊的解决方案：<code>StringFormat</code> 函数。</p><p>同样的方案也适用于另一个 MQL5 API 函数：<code>PrintFormat</code>。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>string StringFormat(const string format, ...)</span></span></code></pre></div><p>该函数根据指定的格式将任意内置类型的参数转换为字符串。 第一个参数是要准备的字符串模板，其中以特殊方式指示了插入变量的位置，并确定了它们的输出格式。 这些控制命令可以与纯文本穿插，纯文本会原封不动地复制到输出字符串中。 后续的函数参数（用逗号分隔）按照模板中为它们预留的顺序和类型列出所有变量。</p><p><img src="`+p+`" alt=""></p><h3 id="格式字符串与-stringformat-参数的交互" tabindex="-1">格式字符串与 <code>StringFormat</code> 参数的交互 <a class="header-anchor" href="#格式字符串与-stringformat-参数的交互" aria-label="Permalink to &quot;格式字符串与 \`StringFormat\` 参数的交互&quot;">​</a></h3><p>格式字符串与 <code>StringFormat</code> 参数的交互</p><p>字符串中的每个变量插入点都用一个格式说明符标记：字符 <code>%</code>，在它之后可以指定一些设置。</p><p>格式字符串从左到右进行解析。 当遇到第一个说明符（如果有的话）时，格式字符串之后的第一个参数的值会根据指定的设置进行转换并添加到结果字符串中。 第二个说明符会导致第二个参数被转换并输出，依此类推，直到格式字符串结束。 模式中说明符之间的所有其他字符都会原封不动地复制到结果字符串中。</p><p>模板中可能不包含任何说明符，也就是说，它可以是一个简单的字符串。 在这种情况下，除了字符串之外，还需要向函数传递一个虚拟参数（该参数不会被放入字符串中）。</p><p>如果要在模板中显示百分号，则应连续写两次 <code>%%</code>。 如果 <code>%</code> 符号没有重复写，那么 <code>%</code> 后面的接下来几个字符总是会被解析为一个说明符。</p><p>说明符的一个必需属性是一个符号，该符号指示下一个函数参数的预期类型和解释。 我们姑且将这个符号称为 <code>T</code>。 那么，在最简单的情况下，一个格式说明符看起来像 <code>%T</code>。</p><p>在一般形式下，说明符可以由更多字段组成（可选字段用方括号表示）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>%[Z][W][.P][M]T</span></span></code></pre></div><p>每个字段都执行其功能，并采用一个允许的值。 接下来，我们将逐步介绍所有字段。</p><h4 id="类型-t" tabindex="-1">类型 <code>T</code> <a class="header-anchor" href="#类型-t" aria-label="Permalink to &quot;类型 \`T\`&quot;">​</a></h4><p>对于整数，可以使用以下字符作为 <code>T</code>，并对相应数字在字符串中的显示方式进行说明：</p><ul><li><code>c</code> — Unicode 字符</li><li><code>C</code> — ANSI 字符</li><li><code>d</code>, <code>i</code> — 有符号十进制数</li><li><code>o</code> — 无符号八进制数</li><li><code>u</code> — 无符号十进制数</li><li><code>x</code> — 无符号十六进制数（小写）</li><li><code>X</code> — 无符号十六进制数（大写字母）</li></ul><p>请记住，根据内部数据存储方法，整数类型还包括内置的 MQL5 类型 <code>datetime</code>、<code>color</code>、<code>bool</code> 和枚举类型。</p><p>对于实数，以下符号可用作 <code>T</code>：</p><ul><li><code>e</code> — 带指数的科学计数法（小写 <code>e</code>）</li><li><code>E</code> — 带指数的科学计数法（大写 <code>E</code>）</li><li><code>f</code> — 普通格式</li><li><code>g</code> — 类似于 <code>f</code> 或 <code>e</code>（选择最紧凑的形式）</li><li><code>G</code> — 类似于 <code>f</code> 或 <code>E</code>（选择最紧凑的形式）</li><li><code>a</code> — 带指数的十六进制科学计数法（小写）</li><li><code>A</code> — 带指数的十六进制科学计数法（大写字母）</li></ul><p>最后，对于字符串，<code>T</code> 字符只有一个可用版本：<code>s</code>。</p><h4 id="整数大小-m" tabindex="-1">整数大小 <code>M</code> <a class="header-anchor" href="#整数大小-m" aria-label="Permalink to &quot;整数大小 \`M\`&quot;">​</a></h4><p>对于整数类型，可以通过在 <code>T</code> 前面加上以下字符或字符组合之一（我们将它们概括为字母 <code>M</code>）来额外显式指定变量的字节大小：</p><ul><li><code>h</code> — 2 字节（<code>short</code>, <code>ushort</code>）</li><li><code>l</code>（小写 <code>L</code>） — 4 字节（<code>int</code>, <code>uint</code>）</li><li><code>I32</code>（大写 <code>i</code>） — 4 字节（<code>int</code>, <code>uint</code>）</li><li><code>ll</code>（两个小写 <code>L</code>） — 8 字节（<code>long</code>）</li><li><code>I64</code>（大写 <code>i</code>） — 8 字节（<code>long</code>, <code>ulong</code>）</li></ul><h4 id="宽度-w" tabindex="-1">宽度 <code>W</code> <a class="header-anchor" href="#宽度-w" aria-label="Permalink to &quot;宽度 \`W\`&quot;">​</a></h4><p><code>W</code> 字段是一个非负十进制数，它指定为格式化值预留的最小字符空间数。 如果变量的值占用的字符数较少，则会在左侧或右侧添加相应数量的空格。 根据对齐方式（请参阅 <code>Z</code> 字段中的标志 <code>—</code>）选择左侧或右侧。 如果存在 <code>0</code> 标志，则会在输出值前面添加相应数量的零。 如果要输出的字符数大于指定的宽度，则宽度设置将被忽略，并且输出值不会被截断。</p><p>如果指定 <code>*</code> 作为宽度，则应在传递的参数列表中指定输出值的宽度。 它应该是在要格式化的变量之前位置的一个 <code>int</code> 类型的值。</p><h4 id="精度-p" tabindex="-1">精度 <code>P</code> <a class="header-anchor" href="#精度-p" aria-label="Permalink to &quot;精度 \`P\`&quot;">​</a></h4><p><code>P</code> 字段也包含一个非负十进制数，并且总是前面有一个点 <code>.</code>。 对于整数 <code>T</code>，此字段指定最小有效数字位数。 如果值占用的位数较少，则在前面添加零。</p><p>对于实数，<code>P</code> 指定小数位数（默认值为 6），<code>g</code> 和 <code>G</code> 说明符除外，对于它们，<code>P</code> 是有效数字的总数（尾数和小数部分）。</p><p>对于字符串，<code>P</code> 指定要显示的字符数。 如果字符串长度超过精度值，则字符串将显示为被截断。</p><p>如果指定 <code>*</code> 作为精度，其处理方式与宽度相同，但控制的是精度。</p><p>固定宽度和/或精度，再加上右对齐，使得能够以整齐的列形式显示值。</p><h4 id="标志-z" tabindex="-1">标志 <code>Z</code> <a class="header-anchor" href="#标志-z" aria-label="Permalink to &quot;标志 \`Z\`&quot;">​</a></h4><p>最后，<code>Z</code> 字段描述标志：</p><ul><li><code>-</code>（减号） — 在指定宽度内左对齐（如果没有该标志，则进行右对齐）；</li><li><code>+</code>（加号） — 在值前面无条件显示 <code>+</code> 或 <code>-</code> 符号（如果没有此标志，仅对负值显示 <code>-</code>）；</li><li><code>0</code> — 如果输出值小于指定宽度，则在输出值前面添加零；</li><li><code></code>（空格） — 如果值是有符号的并且为正，则在显示的值前面放置一个空格；</li><li><code>#</code> — 控制八进制和十六进制数前缀在 <code>o</code>、<code>x</code> 或 <code>X</code> 格式中的显示（例如，对于 <code>x</code> 格式，在显示的数字前面添加前缀 <code>0x</code>，对于 <code>X</code> 格式 — 前缀 <code>0X</code>），控制实数（<code>e</code>、<code>E</code>、<code>a</code> 或 <code>A</code> 格式）中带有零小数部分的小数点的显示，以及一些其他细微差别。</li></ul><p>有关向字符串进行格式化输出的更多可能性，可以在文档中了解。</p><p>函数参数的总数不能超过 64 个。</p><p>如果传递给函数的参数数量大于说明符的数量，则多余的参数将被忽略。</p><p>如果格式字符串中的说明符数量大于参数数量，则系统将尝试用零代替缺失的数据进行显示，但对于字符串说明符，会嵌入一个文本警告（“缺少字符串参数”）。</p><p>如果值的类型与相应说明符的类型不匹配，系统将尝试根据格式从变量中读取数据并显示得到的值（由于对实际数据的内部位表示的错误解释，显示的值可能看起来很奇怪）。 在字符串的情况下，结果中可能会嵌入一个警告（“传递了非字符串”）。</p><p>让我们使用脚本 <code>StringFormat.mq5</code> 来测试这个函数。</p><p>首先，让我们尝试 <code>T</code> 和数据类型说明符的不同选项。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>PRT(StringFormat(&quot;[Infinity Sign] Unicode (ok): %c; ANSI (overflow): %C&quot;, </span></span>
<span class="line"><span>   &#39;∞&#39;, &#39;∞&#39;));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;short (ok): %hi, short (overflow): %hi&quot;, </span></span>
<span class="line"><span>   SHORT_MAX, INT_MAX));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;int (ok): %i, int (overflow): %i&quot;, </span></span>
<span class="line"><span>   INT_MAX, LONG_MAX));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;long (ok): %lli, long (overflow): %i&quot;, </span></span>
<span class="line"><span>   LONG_MAX, LONG_MAX));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;ulong (ok): %llu, long signed (overflow): %lli&quot;, </span></span>
<span class="line"><span>   ULONG_MAX, ULONG_MAX));</span></span></code></pre></div><p>这里既表示了正确的说明符，也表示了不正确的说明符（不正确的在每个指令中排在第二个，并标记为“overflow”，因为传递的值不适合格式类型）。</p><p>日志中的结果如下（这里和下面长行的换行是为了便于发布）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>StringFormat(Plain string,0)=&#39;Plain string&#39;</span></span>
<span class="line"><span>StringFormat([Infinity Sign] Unicode: %c; ANSI: %C,&#39;∞&#39;,&#39;∞&#39;)=</span></span>
<span class="line"><span>   &#39;[Infinity Sign] Unicode (ok): ∞; ANSI (overflow):  &#39;</span></span>
<span class="line"><span>StringFormat(short (ok): %hi, short (overflow): %hi,SHORT_MAX,INT_MAX)=</span></span>
<span class="line"><span>   &#39;short (ok): 32767, short (overflow): -1&#39;</span></span>
<span class="line"><span>StringFormat(int (ok): %i, int (overflow): %i,INT_MAX,LONG_MAX)=</span></span>
<span class="line"><span>   &#39;int (ok): 2147483647, int (overflow): -1&#39;</span></span>
<span class="line"><span>StringFormat(long (ok): %lli, long (overflow): %i,LONG_MAX,LONG_MAX)=</span></span>
<span class="line"><span>   &#39;long (ok): 9223372036854775807, long (overflow): -1&#39;</span></span>
<span class="line"><span>StringFormat(ulong (ok): %llu, long signed (overflow): %lli,ULONG_MAX,ULONG_MAX)=</span></span>
<span class="line"><span>   &#39;ulong (ok): 18446744073709551615, long signed (overflow): -1&#39;</span></span></code></pre></div><p>以下所有指令都是正确的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>PRT(StringFormat(&quot;ulong (ok): %I64u&quot;, ULONG_MAX));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;ulong (HEX): %I64X, ulong (hex): %I64x&quot;, </span></span>
<span class="line"><span>   1234567890123456, 1234567890123456));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %f&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %e&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %g&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %a&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;string: %s&quot;, &quot;ABCDEFGHIJ&quot;));</span></span></code></pre></div><p>它们的执行结果如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>StringFormat(ulong (ok): %I64u,ULONG_MAX)=</span></span>
<span class="line"><span>   &#39;ulong (ok): 18446744073709551615&#39;</span></span>
<span class="line"><span>StringFormat(ulong (HEX): %I64X, ulong (hex): %I64x,1234567890123456,1234567890123456)=</span></span>
<span class="line"><span>   &#39;ulong (HEX): 462D53C8ABAC0, ulong (hex): 462d53c8abac0&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %f,M_PI)=&#39;double PI: 3.141593&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %e,M_PI)=&#39;double PI: 3.141593e+00&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %g,M_PI)=&#39;double PI: 3.14159&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %a,M_PI)=&#39;double PI: 0x1.921fb54442d18p+1&#39;</span></span>
<span class="line"><span>StringFormat(string: %s,ABCDEFGHIJ)=&#39;string: ABCDEFGHIJ&#39;</span></span></code></pre></div><p>现在让我们看看各种修饰符。</p><p>使用右对齐（默认）和固定字段宽度（字符数），我们可以使用不同的选项在结果字符串的左侧进行填充：用空格或零。 此外，对于任何对齐方式，都可以启用或禁用值的符号的显式指示（这样不仅对负值显示减号，对正值也显示加号）。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>PRT(StringFormat(&quot;space padding: %10i&quot;, SHORT_MAX));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;0-padding: %010i&quot;, SHORT_MAX));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;with sign: %+10i&quot;, SHORT_MAX));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;precision: %.10i&quot;, SHORT_MAX));</span></span></code></pre></div><p>我们在日志中得到以下内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>StringFormat(space padding: %10i,SHORT_MAX)=&#39;space padding:      32767&#39;</span></span>
<span class="line"><span>StringFormat(0-padding: %010i,SHORT_MAX)=&#39;0-padding: 0000032767&#39;</span></span>
<span class="line"><span>StringFormat(with sign: %+10i,SHORT_MAX)=&#39;with sign:     +32767&#39;</span></span>
<span class="line"><span>StringFormat(precision: %.10i,SHORT_MAX)=&#39;precision: 0000032767&#39;</span></span></code></pre></div><p>要左对齐，必须使用 <code>-</code>（减号）标志，将字符串添加到指定宽度的操作发生在右侧：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>PRT(StringFormat(&quot;no sign (default): %-10i&quot;, SHORT_MAX));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;with sign: %+-10i&quot;, SHORT_MAX));</span></span></code></pre></div><p>结果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>StringFormat(no sign (default): %-10i,SHORT_MAX)=&#39;no sign (default): 32767     &#39;</span></span>
<span class="line"><span>StringFormat(with sign: %+-10i,SHORT_MAX)=&#39;with sign: +32767    &#39;</span></span></code></pre></div><p>如果需要，我们可以显示或隐藏值的符号（默认情况下，仅对负值显示减号），为正值添加空格，从而在需要以列形式显示变量时确保相同的格式化：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>PRT(StringFormat(&quot;default: %i&quot;, SHORT_MAX));  // 标准</span></span>
<span class="line"><span>PRT(StringFormat(&quot;default: %i&quot;, SHORT_MIN));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;space  : % i&quot;, SHORT_MAX)); // 为正值添加额外空格</span></span>
<span class="line"><span>PRT(StringFormat(&quot;space  : % i&quot;, SHORT_MIN));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;sign   : %+i&quot;, SHORT_MAX)); // 强制输出符号</span></span>
<span class="line"><span>PRT(StringFormat(&quot;sign   : %+i&quot;, SHORT_MIN));</span></span></code></pre></div><p>日志中的内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>StringFormat(default: %i,SHORT_MAX)=&#39;default: 32767&#39;</span></span>
<span class="line"><span>StringFormat(default: %i,SHORT_MIN)=&#39;default: -32768&#39;</span></span>
<span class="line"><span>StringFormat(space  : % i,SHORT_MAX)=&#39;space  :  32767&#39;</span></span>
<span class="line"><span>StringFormat(space  : % i,SHORT_MIN)=&#39;space  : -32768&#39;</span></span>
<span class="line"><span>StringFormat(sign   : %+i,SHORT_MAX)=&#39;sign   : +32767&#39;</span></span>
<span class="line"><span>StringFormat(sign   : %+i,SHORT_MIN)=&#39;sign   : -32768&#39;</span></span></code></pre></div><p>现在让我们比较宽度和精度对实数的影响。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>PRT(StringFormat(&quot;double PI: %15.10f&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %15.10e&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %15.10g&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %15.10a&quot;, M_PI));</span></span>
<span class="line"><span>   </span></span>
<span class="line"><span>// 默认精度 = 6</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %15f&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %15e&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %15g&quot;, M_PI));</span></span>
<span class="line"><span>PRT(StringFormat(&quot;double PI: %15a&quot;, M_PI));</span></span></code></pre></div><p>结果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>StringFormat(double PI: %15.10f,M_PI)=&#39;double PI:    3.1415926536&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %15.10e,M_PI)=&#39;double PI: 3.1415926536e+00&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %15.10g,M_PI)=&#39;double PI:     3.141592654&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %15.10a,M_PI)=&#39;double PI: 0x1.921fb54443p+1&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %15f,M_PI)=&#39;double PI:        3.141593&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %15e,M_PI)=&#39;double PI:    3.141593e+00&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %15g,M_PI)=&#39;double PI:         3.14159&#39;</span></span>
<span class="line"><span>StringFormat(double PI: %15a,M_PI)=&#39;double PI: 0x1.921fb54442d18p+1&#39;</span></span></code></pre></div><p>如果未指定显式宽度，则输出的值不会用空格填充。</p>`,327)]))}const y=i(e,[["render",l]]);export{c as __pageData,y as default};
