import{_ as i,c as a,ag as n,o as h}from"./chunks/framework.CCnnzLsu.js";const g=JSON.parse('{"title":"时间相关函数","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://vite.dev/mq5_programming_for_traders/common_mql5_apis/functions_for_working_with_time"}],["meta",{"property":"og:title","content":"时间相关函数"}]]},"headers":[],"relativePath":"mq5_programming_for_traders/common_mql5_apis/functions_for_working_with_time.md","filePath":"mq5_programming_for_traders/common_mql5_apis/functions_for_working_with_time.md","lastUpdated":1744387121000}'),p={name:"mq5_programming_for_traders/common_mql5_apis/functions_for_working_with_time.md"};function k(e,s,t,l,d,E){return h(),a("div",null,s[0]||(s[0]=[n(`<h1 id="时间相关函数" tabindex="-1">时间相关函数 <a class="header-anchor" href="#时间相关函数" aria-label="Permalink to &quot;时间相关函数&quot;">​</a></h1><p>时间是大多数进程中的一个基本要素，并且在交易中扮演着重要的实际应用角色。</p><p>如我们所知，交易中的主要坐标系基于两个维度：价格和时间。它们分别沿图表的纵轴和横轴显示。稍后，我们将涉及另一个重要的轴，它可以表示为垂直于前两个轴并深入图表内部，在这个轴上标记着交易量。但目前，让我们专注于时间。</p><p>这种时间度量对于所有图表都是通用的，使用相同的度量单位，而且说来奇怪，它的特点是具有恒定性（时间的流逝是可预测的）。</p><p>终端提供了大量与时间计算和分析相关的内置工具。所以，在我们阅读本书各章节的过程中，会从简单到复杂逐步了解它们。</p><p>在本章中，我们将研究那些可以让你控制时间并在指定的时间间隔内暂停程序活动的函数。</p><p>在 “日期和时间” 章节的数据转换部分，我们已经看到了几个与时间相关的函数：<code>TimeToStruct</code> 和 <code>StructToTime</code>。它们可以将 <code>datetime</code> 类型的值拆分为各个组成部分，或者反过来，从各个单独的字段构建 <code>datetime</code>；回想一下，这些字段汇总在 <code>MqlDateTime</code> 结构体中。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MqlDateTime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> year;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 年份（1970年 - 3000年）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mon;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 月份（1 - 12） </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> day;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 日期（1 - 31） </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hour;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 小时（0 - 23） </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> min;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 分钟（0 - 59） </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sec;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 秒（0 - 59） </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> day_of_week;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 星期几，从0（星期日）到6（星期六）编号</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // 根据枚举类型ENUM_DAY_OF_WEEK</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> day_of_year;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 一年中日期的序号，从0（1月1日）开始</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>但是，一个 MQL 程序从哪里获取 <code>datetime</code> 值呢？</p><p>例如，历史价格和时间反映在报价中，而当前的实时数据以报价点（tick）的形式到达。两者都有时间戳，我们将在相关章节中学习如何获取这些时间戳：关于时间序列和终端事件的章节。不过，一个 MQL 程序可以使用几个函数自行查询当前时间（不涉及价格或其他交易信息）。</p><p>之所以需要几个函数，是因为这个系统是分布式的：它由客户端终端和位于世界任意地方的经纪商服务器组成，很可能它们属于不同的时区。</p><p>任何时区的特点都是相对于全球时间参考点 —— 格林威治标准时间（GMT）存在一个时间偏移。通常，时区偏移量是整数小时数 N（尽管也有以半小时为单位的特殊时区），因此根据该时区位于本初子午线的东侧还是西侧，会表示为 GMT + N 或 GMT - N。例如，位于伦敦以东的欧洲大陆使用中欧时间（CET），等于 GMT + 1，或者东欧时间（EET），等于 GMT + 2，而在美国有 “负” 时区，比如东部标准时间（EST），即 GMT - 5。</p><p>需要注意的是，GMT 对应于天文（太阳）时间，由于地球的自转逐渐变慢，这种时间略微呈现非线性。在这方面，近几十年来，实际上已经过渡到了一个更精确的计时系统（基于原子钟），其中全球时间被称为协调世界时（UTC）。在包括交易在内的许多应用领域，GMT 和 UTC 之间的差异并不显著，所以新的 UTC±N 格式和旧的 GMT±N 格式的时区表示应该被视为等效的。例如，许多经纪商已经在他们的规范中以 UTC 来指定交易时段时间，而 MQL5 API 从历史上一直使用 GMT 表示法。</p><p>MQL5 API 允许你查询终端的当前时间（实际上是计算机的本地时间）和服务器时间：它们分别由 <code>TimeLocal</code> 和 <code>TimeCurrent</code> 函数返回。此外，一个 MQL 程序可以根据 Windows 的时区设置获取当前的 GMT 时间（<code>TimeGMT</code> 函数）。这样，交易者和程序员就可以将本地时间与全球时间联系起来，并且通过本地时间和服务器时间之间的差异，可以确定服务器和报价的 “时区”。但这里有几个有趣的要点。</p><p>首先，在许多国家，有实行夏令时（DST）的惯例。通常，这意味着从大约 3 月/4 月到 10 月/11 月（在北半球，南半球则相反），在标准（冬季）时间的基础上增加 1 小时。与此同时，GMT/UTC 时间始终保持不变，即不受夏令时调整的影响，因此客户端和服务器时间之间可能会出现各种收敛/差异的情况：</p><ul><li>不同国家的夏令时转换日期可能不同；</li><li>有些国家不实行夏令时。</li></ul><p>因此，如果某些 MQL 程序的算法是基于对日内时间（例如新闻发布时间）的参考，而不是基于价格走势或交易量集中情况，那么这些程序就需要跟踪这种时区变化。</p><p>而且，如果借助 <code>TimeDaylightSavings</code> 函数很容易确定用户计算机上的时间转换情况，那么对于服务器时间却没有现成的类似函数。</p><p>其次，遗憾的是，常规的 MetaTrader 5 测试器（我们可以在其中调试或评估专家顾问和指标等类型的 MQL 程序）并不模拟交易服务器的时间。相反，上述的三个函数 <code>TimeLocal</code>、<code>TimeGMT</code> 和 <code>TimeCurrent</code> 都会返回相同的时间，即实际上时区始终是 GMT。</p><p>绝对时间和相对时间</p><p>算法中的时间记录，就像在现实生活中一样，可以用绝对坐标或相对坐标来进行。过去、现在和未来的每一个时刻都由一个绝对值来描述，我们可以参考这个绝对值来表示记录周期的开始，或者经济新闻发布的时间。正是这种时间，我们在 MQL5 中使用 <code>datetime</code> 类型来存储。同时，常常需要从当前时刻出发，展望未来或回溯过去给定数量的时间单位。在这种情况下，我们感兴趣的不是绝对值，而是时间间隔。</p><p>特别是，算法中有超时的概念，它是一段时间，在这段时间内必须执行某个操作，如果由于任何原因没有执行该操作，我们就取消它并停止等待结果（因为显然出了问题）。你可以用不同的单位来度量这个间隔：小时、秒、毫秒，甚至微秒（毕竟现在的计算机速度很快）。</p><p>在 MQL5 中，一些与时间相关的函数处理绝对值（例如 <code>TimeLocal</code>、<code>TimeCurrent</code>），而一部分处理时间间隔（例如 <code>GetTickCount</code>、<code>GetMicrosecondCount</code>）。</p><p>然而，度量时间间隔或在指定的时间间隔内激活程序，不仅可以通过本节中的函数来实现，还可以使用内置的定时器，这些定时器按照众所周知的闹钟原理工作。启用后，它们使用特殊事件来通知 MQL 程序，以及我们实现的用于处理这些事件的函数 —— <code>OnTimer</code>（它们类似于 <code>OnStart</code>）。在学习了 MQL5 中事件的一般概念之后（请参阅事件处理函数概述），我们将在单独的部分中介绍时间管理的这一方面。</p><h2 id="本地时间和服务器时间" tabindex="-1">本地时间和服务器时间 <a class="header-anchor" href="#本地时间和服务器时间" aria-label="Permalink to &quot;本地时间和服务器时间&quot;">​</a></h2><p>MetaTrader 5 平台上始终存在两种类型的时间：本地（客户端）时间和服务器（经纪商）时间。</p><p>本地时间对应于运行终端的计算机的时间，并且以与现实世界相同的速率持续增加。</p><p>服务器时间的流逝方式有所不同。其时间基准由经纪商计算机上的时间设定，然而，客户端只有在收到下一次价格变化信息时才会获取到服务器时间，这些价格变化被打包在称为报价点（tick）的特殊结构中（请参阅关于 <code>MqlTick</code> 的部分），并通过事件传递给 MQL 程序。</p><p>因此，只有当市场上至少有一种金融工具（即从 “市场报价” 窗口中所选的那些工具）的价格发生变化时，终端才会知道更新后的服务器时间。服务器的最后已知时间会显示在该窗口的标题栏中。如果没有报价点，终端中的服务器时间就会停滞不前。这在周末和节假日所有交易所和外汇平台都关闭时尤为明显。</p><p>特别是在周日，服务器时间很可能显示为周五晚上的时间。唯一的例外是那些提供如加密货币等持续交易工具的 MetaTrader 5 实例。不过，即使在这种情况下，在市场波动性较低的时期，服务器时间也可能明显落后于本地时间。</p><p>本节中的所有函数处理时间的精度最高可达秒（<code>datetime</code> 类型中时间表示的精度）。</p><p>为了获取本地时间和服务器时间，MQL5 API 提供了三个函数：<code>TimeLocal</code>、<code>TimeCurrent</code> 和 <code>TimeTradeServer</code>。这三个函数都有两种函数原型版本：第一种版本以 <code>datetime</code> 类型的值返回时间，第二种版本额外通过引用接受参数，并使用时间组件填充 <code>MqlDateTime</code> 结构体。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datetime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datetime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MqlDateTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>该函数以 <code>datetime</code> 格式返回本地计算机时间。</p><p>需要注意的是，如果启用了夏令时，该时间包含夏令时。也就是说，<code>TimeLocal</code> 等于计算机时区的标准时间减去夏令时调整值 <code>TimeDaylightSavings</code>。有条件地，该公式可以表示如下：</p><p><code>TimeLocal summer() = TimeLocal winter() - TimeDaylightSavings()</code></p><p>这里 <code>TimeDaylightSavings</code> 通常等于 -3600，即把时钟向前拨 1 小时（少了 1 小时）。所以相对于 UTC，<code>TimeLocal</code> 的夏令时数值大于冬令时数值（在天文时间相同的情况下）。例如，如果在冬季 <code>TimeLocal</code> 等于 UTC+2，那么在夏季它就是 UTC+3。可以使用 <code>TimeGMT</code> 函数获取 UTC 时间。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datetime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datetime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MqlDateTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>该函数以 <code>datetime</code> 格式返回最后已知的服务器时间。这是从 “市场报价” 窗口中所有金融工具列表里最后一个报价的到达时间。唯一的例外是专家顾问中的 <code>OnTick</code> 事件处理程序，在这个处理程序中，该函数将返回已处理报价点的时间（即使在 “市场报价” 窗口中已经出现了时间更新的报价点）。</p><p>此外，请注意，MetaTrader 5 中所有图表横轴上的时间对应于（历史的）服务器时间。最后一个（当前的，最右边的）柱状图包含 <code>TimeCurrent</code> 的时间。详情请参阅 “图表” 部分。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datetime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeTradeServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datetime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeTradeServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MqlDateTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>该函数返回对交易服务器当前时间的估算值。与 <code>TimeCurrent</code> 不同，<code>TimeCurrent</code> 的结果在没有新报价时可能不会改变，而 <code>TimeTradeServer</code> 允许你获取不断增加的服务器时间的估算值。该计算基于客户端和服务器时区的最后已知差值，将该差值加到当前本地时间上得到估算的服务器时间。</p><p>在测试器中，<code>TimeTradeServer</code> 的值始终等于 <code>TimeCurrent</code> 的值。</p><p>脚本 <code>TimeCheck.mq5</code> 中给出了这些函数如何工作的示例。</p><p>主函数有一个无限循环，每秒记录所有类型的时间，直到用户停止脚本。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IsStopped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeTradeServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeTradeServerExact</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      Sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>除了标准函数外，这里还应用了一个自定义函数 <code>TimeTradeServerExact</code>。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datetime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeTradeServerExact</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LOCATION</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      LOCAL, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      SERVER, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> datetime </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shiftInHours </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shiftInSeconds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 不断检测本地和服务器的最后两个时间戳</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">   then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[LOCAL] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[LOCAL];</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">   then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SERVER] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SERVER];</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">   now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[LOCAL] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TimeLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">   now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SERVER] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TimeCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 第一次调用时，我们还没有两个时间标签，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 而这是计算稳定差值所必需的</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[LOCAL] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SERVER] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 当客户端和服务器上的时间进程相同时，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 并且服务器时间没有因为周末/节假日而 “冻结”，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新差值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[LOCAL] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SERVER] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[LOCAL] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SERVER]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   &amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SERVER] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SERVER])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      shiftInSeconds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[LOCAL] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SERVER];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      shiftInHours </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MathRound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shiftInSeconds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3600.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 调试打印</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      PrintFormat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Shift update: hours: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">; seconds: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%lld</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, shiftInHours, shiftInSeconds);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 注意：内置函数 TimeTradeServer 是这样计算的：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   //                TimeLocal() - shiftInHours * 3600</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (datetime)(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shiftInSeconds);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>之所以需要这个自定义函数，是因为内置的 <code>TimeTradeServer</code> 函数的算法可能并不适合所有人。内置函数找到本地时间和服务器时间之间以小时为单位的差值（即时区差值），然后通过对本地时间进行这个差值的校正来得到服务器时间。结果是，如果客户端和服务器上的分钟和秒不同步（这是很有可能的），标准的服务器时间近似值将显示客户端的分钟和秒，而不是服务器的。</p><p>理想情况下，所有计算机的本地时钟都应该与全球时间同步，但在实际中会出现偏差。所以，即使其中一方存在很小的时间偏移，<code>TimeTradeServer</code> 也无法再以最高精度重现服务器上的时间。</p><p>在我们用 MQL5 实现的相同功能中，我们没有将客户端和服务器时间的差值四舍五入到以小时为单位的时区差值。相反，在计算中使用了精确到秒的差值。这就是为什么 <code>TimeTradeServerExact</code> 返回的时间的分钟和秒与服务器上的完全一样。</p><p>以下是该脚本生成的日志示例。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>TimeLocal()=2021.09.02 16:03:34 / ok</span></span>
<span class="line"><span>TimeCurrent()=2021.09.02 15:59:39 / ok</span></span>
<span class="line"><span>TimeTradeServer()=2021.09.02 16:03:34 / ok</span></span>
<span class="line"><span>TimeTradeServerExact()=1970.01.01 00:00:00 / ok</span></span></code></pre></div><p>可以看出，客户端和服务器的时区相同，但存在几分钟的不同步（为了便于理解）。在第一次调用时，<code>TimeTradeServerExact</code> 返回 0。随后，用于计算差值的数据就会到达，我们将看到所有四种时间类型，以几秒的间隔均匀地 “走动”。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>TimeLocal()=2021.09.02 16:03:35 / ok</span></span>
<span class="line"><span>TimeCurrent()=2021.09.02 15:59:40 / ok</span></span>
<span class="line"><span>TimeTradeServer()=2021.09.02 16:03:35 / ok</span></span>
<span class="line"><span>Shift update: hours: 0; seconds: 235</span></span>
<span class="line"><span>TimeTradeServerExact()=2021.09.02 15:59:40 / ok</span></span>
<span class="line"><span>TimeLocal()=2021.09.02 16:03:36 / ok</span></span>
<span class="line"><span>TimeCurrent()=2021.09.02 15:59:41 / ok</span></span>
<span class="line"><span>TimeTradeServer()=2021.09.02 16:03:36 / ok</span></span>
<span class="line"><span>Shift update: hours: 0; seconds: 235</span></span>
<span class="line"><span>TimeTradeServerExact()=2021.09.02 15:59:41 / ok</span></span>
<span class="line"><span>TimeLocal()=2021.09.02 16:03:37 / ok</span></span>
<span class="line"><span>TimeCurrent()=2021.09.02 15:59:41 / ok</span></span>
<span class="line"><span>TimeTradeServer()=2021.09.02 16:03:37 / ok</span></span>
<span class="line"><span>TimeTradeServerExact()=2021.09.02 15:59:42 / ok</span></span>
<span class="line"><span>TimeLocal()=2021.09.02 16:03:38 / ok</span></span>
<span class="line"><span>TimeCurrent()=2021.09.02 15:59:43 / ok</span></span>
<span class="line"><span>TimeTradeServer()=2021.09.02 16:03:38 / ok</span></span>
<span class="line"><span>TimeTradeServerExact()=2021.09.02 15:59:43 / ok</span></span></code></pre></div><h2 id="夏令时-本地" tabindex="-1">夏令时（本地） <a class="header-anchor" href="#夏令时-本地" aria-label="Permalink to &quot;夏令时（本地）&quot;">​</a></h2><p>为了判断本地时钟是否切换到夏令时，MQL5 提供了 <code>TimeDaylightSavings</code> 函数。它会从你的操作系统获取设置。</p><p>要确定服务器上的夏令时情况并非易事。为此，你需要在 MQL5 中对报价、经济日历事件或者账户交易历史中的展期/掉期时间进行分析。下面的示例将展示其中一种方法。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TimeDaylightSavings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>如果启用了夏令时，该函数会返回以秒为单位的调整值。冬令时是每个时区的标准时间，所以在此期间调整值为零。用条件公式表示获取调整值的方式如下：</p><p><code>TimeDaylightSavings() = TimeLocal winter() - TimeLocal summer()</code></p><p>例如，如果标准时区（冬令时）是 UTC+3（即该时区时间比 UTC 快 3 小时），那么在切换到夏令时（夏令时）时，我们会增加 1 小时，得到 UTC+4。此时 <code>TimeDaylightSavings</code> 会返回 -3600。</p><p>脚本 <code>TimeSummer.mq5</code> 给出了该函数的使用示例，此脚本还提出了一种在服务器上识别相应模式的经验性方法。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 终端的本地时间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 最后已知的服务器时间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeTradeServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 估算的服务器时间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeGMT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // GMT 时间（通过时区偏移从本地时间计算得出）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeGMTOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 与 GMT 相比的时区偏移，以秒为单位</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeDaylightSavings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 夏令时的调整值，以秒为单位</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ...</span></span></code></pre></div><p>首先，我们要显示 MQL5 提供的所有时间类型及其调整值（<code>TimeGMT</code> 和 <code>TimeGMTOffset</code> 函数将在下一节 “世界时” 中介绍，但从之前的描述中你应该大致能明白它们的含义）。</p><p>该脚本应在交易日运行。日志中的记录会与你的计算机设置以及经纪商服务器的设置相对应。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>TimeLocal()=2021.09.09 22:06:17 / ok</span></span>
<span class="line"><span>TimeCurrent()=2021.09.09 22:06:10 / ok</span></span>
<span class="line"><span>TimeTradeServer()=2021.09.09 22:06:17 / ok</span></span>
<span class="line"><span>TimeGMT()=2021.09.09 19:06:17 / ok</span></span>
<span class="line"><span>TimeGMTOffset()=-10800 / ok</span></span>
<span class="line"><span>TimeDaylightSavings()=0 / ok</span></span></code></pre></div><p>在这种情况下，客户端的时区比 GMT 快 3 小时（UTC+3），且没有夏令时调整。</p><p>现在来看看服务器。根据 <code>TimeCurrent</code> 函数的值，我们可以确定服务器的当前时间，但无法确定其标准时区，因为这个时间可能包含了夏令时的转换（MQL5 并未提供是否使用夏令时以及当前是否启用的相关信息）。</p><p>为了确定服务器的实际时区和夏令时情况，我们可以利用服务器时间转换会影响报价这一特点。和大多数解决问题的经验性方法一样，这种方法在某些情况下可能无法得出完全准确的结果。如果与其他来源的比较显示存在差异，就应该选择其他方法。</p><p>外汇市场在周日 22:00 UTC 开盘（这对应亚太地区早盘交易的开始），并在周五 22:00 收盘（美国交易时段结束）。这意味着在 UTC+2 时区（东欧）的服务器上，周一凌晨 0 点 0 分将恰好出现第一根 K 线。按照中欧时间（对应 UTC+1），交易周从周日 23:00 开始。</p><p>通过计算每个周末休市后第一根 H1 周期 K 线的日内偏移统计数据，我们可以估算出服务器的时区。当然，为此最好使用流动性最强的外汇交易品种，即欧元兑美元（EURUSD）。</p><p>如果在一年的统计数据中发现两个相邻的最大日内偏移，这意味着经纪商正在进行夏令时的切换，反之亦然。</p><p>需要注意的是，夏令时和冬令时的时长并不相等。因此，在 3 月初切换到夏令时以及 11 月初恢复到冬令时时，我们会有大约 8 个月的夏令时。这会影响统计数据中的最大值比例。</p><p>知道了两个时区后，我们就能轻松确定当前哪个时区处于激活状态，从而了解当前是否存在夏令时调整。</p><p>当时钟切换到夏令时时，经纪商的时区会从 UTC+2 变为 UTC+3，这会使交易周的开始时间从 22:00 提前到 21:00。这会影响 H1 周期 K 线的结构：在图表上，我们会看到周日晚上有三根 K 线，而不是两根。</p><h3 id="eurusd-h1-图表上从冬令时-utc-2-切换到夏令时-utc-3-的情况" tabindex="-1">EURUSD H1 图表上从冬令时（UTC+2）切换到夏令时（UTC+3）的情况 <a class="header-anchor" href="#eurusd-h1-图表上从冬令时-utc-2-切换到夏令时-utc-3-的情况" aria-label="Permalink to &quot;EURUSD H1 图表上从冬令时（UTC+2）切换到夏令时（UTC+3）的情况&quot;">​</a></h3><p>为了实现这一点，我们有一个单独的函数 <code>ServerTimeZone</code>。内置的 <code>CopyTime</code> 函数调用负责获取报价，更准确地说是 K 线的时间戳（我们将在 “访问时间序列” 部分学习该函数）。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ServerTime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ServerTimeZone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string symbol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> year </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 365</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 60</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  datetime array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CopyTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbol, PERIOD_H1, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> year, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), array)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 这里数组中大约有 6000 根 K 线</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArraySize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     PrintFormat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Got </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> H1 bars, ~</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> days&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n, n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // (-V-) 遍历 H1 周期 K 线</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>CopyTime</code> 函数接收交易品种、H1 时间周期以及过去一年的日期范围作为参数。用 <code>NULL</code> 代替交易品种表示脚本所在的当前图表的交易品种，因此建议选择欧元兑美元的图表窗口。如你所料，<code>PERIOD_H1</code> 常量对应 H1 时间周期。我们已经熟悉了 <code>TimeCurrent</code> 函数：它会返回服务器的当前最新已知时间。如果从这个时间中减去一年的秒数（存储在 <code>year</code> 变量中），我们就会得到正好一年前的日期和时间。结果将存储在数组中。</p><p>为了统计一周在特定小时开始的次数，我们预留了 <code>hours[24]</code> 数组。计算将在遍历结果数组（即从过去到现在的 K 线）的循环中进行。在每次迭代中，当前查看的交易周的开盘小时将存储在 <code>current</code> 变量中。当循环结束时，<code>current</code> 变量中将保留服务器的当前时区，因为最后处理的是当前交易周。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // (-v-) 遍历 H1 周期 K 线</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> hours</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // (-V-) 处理第 i 根 H1 周期 K 线</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Week opening hours stats:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     ArrayPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hours);</span></span></code></pre></div><p>在遍历日期的循环内部，我们将使用头文件 <code>MQL5Book/DateTime.mqh</code> 中的 <code>datetime</code> 类（见 “日期和时间”）。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // (-v-) 处理第 i 根 H1 周期 K 线</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 查找 K 线所在的星期几</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ENUM_DAY_OF_WEEK weekday </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TimeDayOfWeek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i]);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 跳过除周日和周一之外的所有日期</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(weekday </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MONDAY) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 分析下一个交易周的第一根 H1 周期 K 线</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 查找周末后的第一根 K 线的小时数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _TimeHour</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 计算开盘小时统计数据</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        hours</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[current]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 跳过接下来的 2 天</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // （因为本周开始的统计数据已经更新）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 48</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>所提出的算法并非最优，但它不需要了解时间序列组织的技术细节，而这些细节我们目前还不清楚。</p><p>有些交易周可能不规范（节假日后开始）。如果这种情况出现在最后一周，<code>current</code> 变量将包含一个异常的偏移量。这可以通过统计数据来验证：对于得到的小时数，记录的交易周 “开盘” 次数会非常少。在测试脚本中，这种情况下只会在日志中显示一条消息。在实际应用中，你应该确认前一到两周的标准开盘时间。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // (-V-) 遍历 H1 周期 K 线</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hours</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[current] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 52</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // TODO: 检查前几周</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Extraordinary week detected&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span></code></pre></div><p>如果经纪商不进行夏令时切换，统计数据中将只有一个最大值，这个最大值将包含所有或几乎所有的交易周。如果经纪商实行时区变更，统计数据中将有两个最大值。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 找到最频繁的时间偏移</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayMaximum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hours);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 然后检查是否有另一个常规偏移</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">     hours</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[max] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sub </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayMaximum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hours);</span></span></code></pre></div><p>我们需要确定第二个极值的显著性（即与可能导致交易周开始时间偏移的随机节假日不同）。为此，我们评估一年四分之一（52 周 / 4）的统计数据。如果超过这个限制，说明经纪商支持夏令时。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DST </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hours</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[sub] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 52</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 基本上，支持夏令时</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sub)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MathMin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(max, sub))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              DST </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fabs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sub);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 现在启用了夏令时</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span></code></pre></div><p>如果当前交易周的开盘偏移量（存储在 <code>current</code> 变量中）与两个主要极值之一相符，那么当前交易周的开盘正常，可以据此得出关于时区的结论（这个保护条件是必要的，因为我们没有对非标准交易周进行调整，只是发出了警告）。</p><p>现在，我们已经准备好形成函数的返回结果：服务器时区和夏令时启用标志。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DST;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // +2 以得到相对于 UTC 的偏移量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 时区始终在 [UTC - 12, UTC + 12] 范围内</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>由于我们需要从函数中返回两个特征（<code>current</code> 和 <code>DST</code>），此外，我们还可以告知调用代码经纪商是否一开始就使用夏令时（即使现在是冬季），因此有必要声明一个特殊的结构体 <code>ServerTime</code>，包含所有所需的字段。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ServerTime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offsetGMT;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 相对于 UTC/GMT 的时区偏移，以秒为单位</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offsetDST;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 夏令时调整值，以秒为单位（包含在 offsetGMT 中）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> supportDST;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 原则上在报价中检测到夏令时调整</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string description;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 结果描述</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>然后，在 <code>ServerTimeZone</code> 函数中，我们可以填充并返回这样一个结构体作为函数的执行结果。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     ServerTime st </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     st.description </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringFormat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Server time offset: UTC</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%+d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, including DST</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%+d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, current, DST);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     st.offsetGMT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3600</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     st.offsetDST </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DST </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3600</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> st;</span></span></code></pre></div><p>如果由于某种原因函数无法获取报价，我们将返回一个空结构体。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ServerTime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ServerTimeZone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string symbol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> year </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 365</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 60</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  datetime array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CopyTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbol, PERIOD_H1, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> year, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeCurrent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), array)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> st;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ServerTime empty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">INT_MAX, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">INT_MAX, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> empty;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>让我们来测试这个新函数的实际效果，为此在 <code>OnStart</code> 函数中添加以下指令：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ServerTime st </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ServerTimeZone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(st.description);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ServerGMTOffset: &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, st.offsetGMT);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ServerTimeDaylightSavings: &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, st.offsetDST);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>让我们看看可能的结果。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>CopyTime(symbol,PERIOD_H1,TimeCurrent()-year,TimeCurrent(),array)=6207 / ok</span></span>
<span class="line"><span>Got 6207 H1 bars, ~258 days</span></span>
<span class="line"><span>Week opening hours stats:</span></span>
<span class="line"><span>52  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</span></span>
<span class="line"><span>Server time offset: UTC+2, including DST+0</span></span>
<span class="line"><span>ServerGMTOffset: -7200</span></span>
<span class="line"><span>ServerTimeDaylightSavings: 0</span></span></code></pre></div><p>根据收集的 H1 周期 K 线统计数据，该经纪商的交易周严格在周一 00:00 开始。因此，实际时区为 UTC+2，且没有夏令时调整，即服务器时间必须与东欧时间（EET，UTC+2）相符。然而，实际上，正如我们在日志的第一部分看到的，服务器时间与 GMT 相差 3 小时。</p><p>在这里，我们可以假设遇到了一个全年使用夏令时的服务器。在这种情况下，<code>ServerTimeZone</code> 函数将无法区分调整值和 “时区” 中的额外一小时：结果，夏令时模式将等于零，从服务器报价计算出的 GMT 时间将比实际时间偏移一小时。或者我们最初假设报价在周日 22:00 开始到达与该服务器的运行模式不符。这些问题应该向经纪商的客服人员进行确认。</p><h2 id="世界时" tabindex="-1">世界时 <a class="header-anchor" href="#世界时" aria-label="Permalink to &quot;世界时&quot;">​</a></h2><p>在 MQL5 中，你可以根据计算机的本地时间及其所在时区来查询全球的格林威治标准时间（GMT，即协调世界时 UTC）。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datetime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeGMT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datetime </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TimeGMT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MqlDateTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>该函数以 <code>datetime</code> 格式返回格林威治标准时间，它从计算机的本地时间出发进行计算，并考虑到冬令时或夏令时的转换。</p><p>通用的计算公式为：</p><p><code>TimeGMT() = TimeLocal() + TimeGMTOffset()</code></p><p>因此，世界时表示的准确性取决于本地计算机上时钟的正确设置。理想情况下，获取到的值应该与服务器所记录的值相匹配。</p><p>对于基于外部经济新闻的交易策略而言，最简便的方法是使用格林威治标准时间时区的日历：这样一来，即将发生的事件就可以通过 <code>TimeGMT</code> 函数来追踪。若要将某个事件与图表上的服务器时间关联起来，你需要根据服务器时区与格林威治标准时间的差值（<code>TimeTradeServer() - TimeGMT()</code>）来对该事件进行校正。但请记住，MQL5 有其自身内置的日历。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TimeGMTOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>该函数基于 Windows 中的时区设置，返回当前格林威治标准时间与计算机本地时间之间的差值（以秒为单位），同时会考虑到当前是否处于夏令时。在大多数情况下，时区是以相对于格林威治标准时间的整数小时数来表示的，所以 <code>TimeGMTOffset</code> 等于时区数乘以 -3600（转换为秒）。例如，在冬季，时区可能是 UTC + 2，这会得到 -7200 的偏移量；而在夏季，时区可能是 UTC + 3，得到的偏移量则是 -10800。这里使用负号是因为，当将正的时区时间转换为格林威治标准时间时，需要减去上述秒数，而对于负的时区时间，则需要加上相应的秒数。</p><p>上一节中展示了一个使用 <code>TimeGMT</code> 和 <code>TimeGMTOffset</code> 函数的脚本。</p><h2 id="程序暂停" tabindex="-1">程序暂停 <a class="header-anchor" href="#程序暂停" aria-label="Permalink to &quot;程序暂停&quot;">​</a></h2><p>从之前的示例可以看出，程序有时需要周期性地重复执行某些操作，可能是按照简单的时间表，也可能是在之前的尝试失败之后。当在循环中执行这些操作时，建议定期暂停程序，以避免过于频繁的请求和不必要的 CPU 负载，同时也为外部“参与者”留出执行工作的时间（例如，当我们等待来自其他程序的数据、加载报价历史等）。</p><p>为此，MQL5 提供了 <code>Sleep</code> 函数。本节将对其进行正式描述，下一节将结合时间间隔测量函数给出一个示例。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> milliseconds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>该函数会将 MQL 程序的执行暂停指定的毫秒数。暂停时间结束后，<code>Sleep</code> 调用之后的指令将继续执行。</p><p>该函数首先适用于脚本和服务，因为这类程序没有其他等待方式。</p><p>对于专家顾问和指标，建议使用定时器和 <code>OnTimer</code> 事件。在这种机制下，MQL 程序会将控制权交还给终端，并在指定的时间间隔后被再次调用。</p><p>此外，不能从指标中调用 <code>Sleep</code> 函数，因为指标是在终端界面线程中执行的，暂停该线程会影响图表的渲染。</p><p>如果用户在 MQL 程序等待 <code>Sleep</code> 调用完成时从终端界面中断该程序，函数将立即退出（在 100 毫秒内），即暂停提前结束。这将设置停止标志 <code>_StopFlag</code>（也可以通过 <code>IsStopped</code> 函数获取），程序应尽快且正确地停止执行。</p><h2 id="时间间隔计数器" tabindex="-1">时间间隔计数器 <a class="header-anchor" href="#时间间隔计数器" aria-label="Permalink to &quot;时间间隔计数器&quot;">​</a></h2><p>要检测精确到秒的时间间隔，只需获取使用 <code>TimeLocal</code> 函数得到的两个 <code>datetime</code> 值之间的差值即可。然而，有时我们需要更高的精度。为此，MQL5 允许你获取系统的毫秒计数器（<code>GetTickCount</code>、<code>GetTickCount64</code>）或微秒计数器（<code>GetMicrosecondCount</code>）。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GetTickCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ulong </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetTickCount64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>这些函数返回自操作系统加载以来经过的毫秒数。计时精度受限于标准系统定时器（约 10 - 15 毫秒）。要更精确地测量时间间隔，请使用 <code>GetMicrosecondCount</code> 函数。</p><p>对于 <code>GetTickCount</code> 函数，其返回类型 <code>uint</code> 预先决定了计数器溢出的时间段：大约 49.7 天。换句话说，如果计算机长时间不关机，倒计时将从 0 重新开始。</p><p>相比之下，<code>GetTickCount64</code> 函数返回 <code>ulong</code> 类型的值，并且这个计数器在可预见的未来（584,942,417 年）都不会溢出。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ulong </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetMicrosecondCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>该函数返回自 MQL 程序启动以来经过的微秒数。</p><p>计数器函数和 <code>Sleep</code> 函数的使用示例汇总在脚本 <code>TimeCount.mq5</code> 中。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OnStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startMs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GetTickCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ulong startMcs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  GetMicrosecondCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 循环 5 秒</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetTickCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startMs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetMicrosecondCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      Sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetTickCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startMs);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   PRTF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetMicrosecondCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startMcs);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以下是该脚本的日志输出示例。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>GetTickCount()=12912811 / ok</span></span>
<span class="line"><span>GetMicrosecondCount()=278 / ok</span></span>
<span class="line"><span>GetTickCount()=12913903 / ok</span></span>
<span class="line"><span>GetMicrosecondCount()=1089845 / ok</span></span>
<span class="line"><span>GetTickCount()=12914995 / ok</span></span>
<span class="line"><span>GetMicrosecondCount()=2182216 / ok</span></span>
<span class="line"><span>GetTickCount()=12916087 / ok</span></span>
<span class="line"><span>GetMicrosecondCount()=3273823 / ok</span></span>
<span class="line"><span>GetTickCount()=12917179 / ok</span></span>
<span class="line"><span>GetMicrosecondCount()=4365889 / ok</span></span>
<span class="line"><span>GetTickCount()=12918271 / ok</span></span>
<span class="line"><span>GetTickCount()-startMs=5460 / ok</span></span>
<span class="line"><span>GetMicrosecondCount()-startMcs=5458271 / ok</span></span></code></pre></div>`,138)]))}const c=i(p,[["render",k]]);export{g as __pageData,c as default};
